<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Vexara AI Assistant</title>
    <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/uicons-regular-rounded/css/uicons-regular-rounded.css">

    <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/uicons-regular-rounded/css/uicons-regular-rounded.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">    
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-rounded/css/uicons-regular-rounded.css'>
    <style>
        /* CSS Variables for ChatGPT-like theming */
        :root {
            --primary-color: #10a37f; /* ChatGPT green */
            --primary-light: #18cd9f;
            --accent-color: #6a0dad; /* A subtle purple/blue for some accents */
            --bg-color: #f8f8f8; /* Light gray for body background */
            --text-color: #303030; /* Darker text */
            --text-light: #606060;
            --sidebar-bg: #202123; /* Dark background for sidebar */
            --sidebar-text: #ececf1;
            --chat-bg: #ffffff; /* White chat background */
            --user-message-bg: #e0e7ff; /* Lighter blue for user messages, or a very light gray if preferred */
            --bot-message-bg: #f7f7f8; /* Very light gray for bot messages */
            --code-bg: #2d2d2d; /* Dark code blocks */
            --code-text-color: #f8f8f2; /* Light text for code */
            --border-radius: 10px; /* Slightly more rounded corners for main elements */
            --border-radius-sm: 6px; /* Smaller radius for buttons/inputs */
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* Softer shadows */
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.2s ease-in-out; /* Smooth transitions */
        }

        /* Dark Mode Variables */
        .dark-mode {
            --primary-color: #10a37f;
            --primary-light: #18cd9f;
            --accent-color: #6a0dad;
            --bg-color:#292a2d; /* Dark background */
            --text-color: #d1d5db; /* Lighter text */
            --text-light: #a0a0a0;
            --sidebar-bg:#202123; /* Same dark sidebar */
            --sidebar-text: #ececf1;
            --chat-bg: #292a2d; /* Dark chat background */
            --user-message-bg: #303131t; /* Slightly darker user messages */
            --bot-message-bg: transparent; /* Consistent dark bot messages */
            --code-bg: #2d2d2d;
            --code-text-color: #f8f8f2;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
            display: flex;
            min-height: 100vh; /* Ensures body takes full viewport height */
            overflow: hidden; /* Prevents body scroll when sidebar is fixed */
        }

        /* Sidebar Styles */
        .sidebar {
            width: 260px; /* Slightly narrower like ChatGPT */
            background: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 16px; /* Reduced padding slightly */
            display: flex;
            flex-direction: column;
            height: 100vh;
            flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease, transform 0.3s ease;
            overflow-x: hidden;
            position: relative;
            z-index: 100;
            border-right: 1px solid rgba(255, 255, 255, 0.05); /* Subtle border */
        }

        .sidebar.collapsed {
            width: 70px; /* Collapsed width */
            padding: 16px 10px; /* Adjust padding for collapsed state */
            min-width: 70px; /* Ensures it collapses to this width */
        }

        /* Main Content Styles */
        .main {
            flex: 1; /* Takes remaining space */
            display: flex;
            flex-direction: column;
            height: 100vh; /* Ensure main also takes full viewport height */
            margin-left: 260px; /* Default margin for desktop, equals sidebar width */
            transition: margin-left 0.3s ease;
            position: relative; /* For z-index context */
        }

        .main.full-width { /* Applied when sidebar is collapsed on desktop */
            margin-left: 70px; /* Adjusted margin when sidebar is collapsed */
        }

        .main.full-screen { /* For true full screen chat (sidebar hidden) */
            margin-left: 0;
            width: 100%;
        }

        /* Floating sidebar toggle button */
        #showSidebarBtn {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            
            background: transparent; /* ⬅️ Use transparent */
            color: var(--sidebar-text); /* Match sidebar text color */
            
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            
            box-shadow: none; /* Remove shadow for a clean flat look */
            transition: var(--transition);
            
            align-items: center;
            justify-content: center;
            margin-top: 80px;
        }

        /* Optional hover effect */
        #showSidebarBtn:hover {
            background: rgba(255, 255, 255, 0.1); /* Light hover, or keep transparent */
            transform: scale(1.05);
        }


        /* Sidebar Toggle button inside the sidebar header */
        .sidebar-toggle {
            background: none;
            border: none;
            color: var(--sidebar-text);
            font-size: 1.3rem; /* Slightly smaller for internal toggle */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transition: var(--transition);
        }

        .sidebar-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar.collapsed .sidebar-toggle {
            transform: rotate(180deg); /* Rotate for collapsed state */
            
           
        }

        /* Responsive Adjustments */
        @media (min-width: 769px) {
            .main {
                margin-left: 260px; /* Default margin for desktop */
            }
            .sidebar.collapsed + .main { /* When sidebar is collapsed, main takes full width */
                margin-left: 70px; /* Adjusted margin when sidebar is collapsed */
            }
            /* #showSidebarBtn is now used on desktop too when sidebar is fully hidden */
        }

        @media (max-width: 768px) {
            /* On mobile, sidebar is fixed and slides out */
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                transform: translateX(-100%); /* Hidden off-screen */
                width: 260px; /* Fixed width when visible */
                z-index: 100; /* Ensure it's above main content */
                box-shadow: var(--shadow-md);
            }
            .sidebar.visible { /* Class to show sidebar on mobile */
                transform: translateX(0);
            }
            .main {
                margin-left: 0; /* Main content always full width on mobile */
            }
            #showSidebarBtn {
                display: flex !important; /* Show floating button on mobile */
            }
            /* Hide most sidebar content when collapsed on desktop, or when mobile */
            .sidebar.collapsed .sidebar-header span,
            .sidebar.collapsed .new-chat-btn span,
            .sidebar.collapsed #chat-history-list,
            .sidebar.collapsed .sidebar-footer > *:not(.sidebar-toggle) { /* Exclude toggle for specific hide */
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.1s ease;
            }
            /* Show content when not collapsed on desktop, or when mobile and visible */
            .sidebar:not(.collapsed) .sidebar-header span,
            .sidebar:not(.collapsed) .new-chat-btn span,
            .sidebar:not(.collapsed) #chat-history-list,
            .sidebar:not(.collapsed) .sidebar-footer > *:not(.sidebar-toggle) {
                opacity: 1;
                pointer-events: all;
            }
        }
        sidebar.collapsed #chat-history-list{
            display: none;
        }
        

/* Sidebar Content */
.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Logo Styling */
.sidebar-logo {
    font-size: 1.4rem;
    font-weight: 700;
    color: #fff;
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
    transition: all 0.3s ease;
}

/* ✅ Hide image by default (sidebar open) */
.sidebar-logo img {
    display: none;
}

/* ✅ Show only when sidebar is collapsed */
.sidebar.collapsed .sidebar-logo img {
    display: inline-block;
    width: 55px; /* Slightly larger for better visibility */
    height: 55px;
    object-fit: cover; /* Ensures a clean square fit */
    /* background: rgba(16, 163, 127, 0.08);  */
    padding: 8px; /* Adds spacing inside */
    border-radius: 12px; /* Rounded edges for a polished look */
    /* filter: drop-shadow(0 2px 6px rgba(192, 203, 200, 0.3));  */
    transition: all 0.3s ease;
}

/* Hover effect for a modern feel */
.sidebar.collapsed .sidebar-logo img:hover {
   cursor: pointer;
    transform: scale(1.05); /* Slight zoom on hover */
 
}


/* Hide text only in collapsed mode */
.sidebar.collapsed .sidebar-logo span {
    display: none;
}



        .new-chat-btn {
            background: transparent; /* No background color */
            color: white;
            border: none;
            padding: 12px;
            border-radius: var(--border-radius-sm);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            box-shadow: none; /* Optional: remove shadow if you want clean transparency */
        }

        .new-chat-btn:hover {
            background: #292a2d; /* Or transparent if you don’t want any hover bg */
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .sidebar.collapsed .new-chat-btn {
            padding: 25px;
            margin-top: 90px;
            justify-content: center;
            width: 50px;
            height: 70px;
            border-radius: 50%;
            z-index: 10;
            /* padding-bottom: 10px; */
        }

        .sidebar.collapsed .new-chat-btn span {
            display: none;
        }
        

        #chat-history-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.1);
        }

        #chat-history-list::-webkit-scrollbar {
            width: 6px;
        }

        #chat-history-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        #chat-history-list::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
        }

        .chat-link {
            padding: 10px 12px;
            border-radius: var(--border-radius-sm);
            margin-bottom: 6px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: var(--transition);
            color: var(--sidebar-text);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            position: relative; /* For positioning action buttons */
        }

        .chat-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .chat-link.active {
            background: rgba(255, 255, 255, 0.15); /* More subtle active state for history */
            font-weight: 500;
        }

        .sidebar.collapsed .chat-link {
            width: 50px; /* Square for icons */
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            font-size: 1.1rem;
            border-radius: 50%; /* Make them circular when collapsed */
            
        }

        .sidebar.collapsed .chat-link span {
            display: none;
        }
        
        /* Chat Link Actions (Rename/Delete) */
        .chat-link-actions {
            display: flex;
            gap: 5px;
            margin-left: auto; /* Push to the right */
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* Initially non-interactive */
        }

        .chat-link:hover .chat-link-actions,
        .chat-link.active .chat-link-actions { /* Show actions on hover or when active */
            opacity: 1;
            pointer-events: all;
        }

        .chat-link-actions button {
            background: none;
            border: none;
            color: var(--sidebar-text);
            font-size: 0.85rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-link-actions button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-link-actions button.delete-chat-btn {
            color: #ff6b6b; /* Red for delete */
        }
        .chat-link-actions button.delete-chat-btn:hover {
            background: rgba(255, 107, 107, 0.3);
        }

        .sidebar.collapsed .chat-link-actions {
            display: none; /* Hide actions when sidebar is collapsed */
        }

        .sidebar-footer {
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 10px 12px;
            text-align: left;
            background: none;
            border: none;
            color: var(--sidebar-text);
            border-radius: var(--border-radius-sm);
            margin-bottom: 6px;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.95rem;
        }

        .sidebar-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-btn i {
            margin-right: 10px;
            width: 20px; /* Fixed width for icons */
            text-align: center;
            font-size: 1rem;
        }

        .sidebar.collapsed .sidebar-btn {
            justify-content: center;
            padding: 12px 0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
        }

        .sidebar.collapsed .sidebar-btn i {
            margin-right: 0;
            font-size: 1.2rem;
        }

        .sidebar.collapsed .sidebar-btn span { /* NEW: Hide text for sidebar buttons when collapsed */
            display: none;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--border-radius-sm);
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: var(--sidebar-text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .user-info i {
            font-size: 1.2rem;
            color: var(--accent-color); /* Use accent color for user icon */
        }

        .user-email {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sidebar.collapsed .user-info {
            justify-content: center;
            padding: 10px 0;
            width: 50px;
            height: 50px;
            margin: 0 auto 15px auto;
            border-radius: 50%;
        }

        .sidebar.collapsed .user-info i {
            font-size: 1.4rem;
            margin-right: 0;
        }

        .sidebar.collapsed .user-info .user-email {
            display: none;
        }

        /* Top Bar Styles (Main content header) */
        .top-bar {
            padding: 12px 20px;
            background-color: var(--chat-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05); /* Subtle bottom border */
        }

        .dark-mode .top-bar {
            border-bottom-color: rgba(255, 255, 255, 0.05);
        }

        .top-bar-title {
            font-weight: 600;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-color);
        }

        .top-bar-title i {
            color: var(--primary-light); /* Accent color for the logo in top bar */
            text-shadow: 0 0 5px rgba(24, 205, 159, 0.3);
        }

        .top-bar-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .action-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Full screen button with tooltip */
        .full-screen-btn {
            position: relative;
        }

        .full-screen-btn .tooltip {
            position: absolute;
            bottom: 120%; /* Position above button */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); /* Darker tooltip background */
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
            z-index: 100;
            margin-bottom: 8px;
        }

        .full-screen-btn:hover .tooltip {
            opacity: 1;
        }

        /* Chat Container Styles */
        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: var(--chat-bg);
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--chat-bg);
            display: flex;
            flex-direction: column;
            gap: 16px; /* Spacing between messages */
            font-size: 1rem;
            line-height: 1.6;
            scroll-behavior: smooth;
        }

        .chat-container::-webkit-scrollbar {
            width: 8px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: var(--chat-bg);
            border-radius: 10px;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
            border: 2px solid var(--chat-bg);
        }

        .chat-container::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary-light);
        }

        /* Initial New Chat Screen */
        .new-chat-placeholder {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text-light);
            font-size: 1.2rem;
            text-align: center;
            padding-bottom: 100px; /* Space for the input area */
            gap: 20px;
        }

        .new-chat-placeholder .logo-large {
            font-size: 3rem;
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(16, 163, 127, 0.3);
        }

        .new-chat-placeholder .title {
            font-size: 2rem;
            font-weight: 600;
            color: var(--text-color);
        }

        /* Individual Chat Message Styles */
        .chat-message {
            /* Max width to keep messages readable, centered in the chat container */
            max-width: 768px; /* Standard readable width for content */
            margin-left: auto; /* For user messages */
            margin-right: auto; /* For bot messages */
            padding: 16px 20px;
            border-radius: var(--border-radius);
            word-break: break-word;
            position: relative;
            background-color: var(--bot-message-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: var(--transition);
            box-shadow: var(--shadow);
            animation: fadeIn 0.3s ease-out; /* Fade in animation for new messages */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* User Messages */
.user-message {
    background-color: var(--user-message-bg);
    margin-left: auto;
    margin-right: 0;
    padding: 14px 18px;
    border-radius: 12px 12px 4px 12px; /* Rounded with unique flair */
    max-width: 70%;
    color: var(--text-color);
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInRight 0.25s ease-out;
    backdrop-filter: blur(6px);
}

/* Bot Messages */
.bot-message {
    background-color: var(--bot-message-bg);
    margin-right: auto;
    margin-left: 0;
    padding: 14px 18px;
    border-radius: 12px 12px 12px 4px; /* Rounded with unique flair */
    max-width: 70%;
    color: var(--text-color);
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInLeft 0.25s ease-out;
    backdrop-filter: blur(6px);
}

/* Animations */
@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes slideInLeft {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}


        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.9em;
            color: var(--text-light); /* Make header text slightly lighter */
        }

        .message-timestamp {
            font-weight: normal;
            font-size: 0.8em;
            opacity: 0.7;
            margin-left: auto; /* Push timestamp to the right */
            color: var(--text-light);
        }

        .message-header i {
            margin-right: 8px;
            color: var(--primary-color);
        }

        .message-content {
            margin-top: 10px;
            color: var(--text-color);
        }

        .message-content p {
            margin-bottom: 10px; /* Space between paragraphs in messages */
        }

        .message-content p:last-child {
            margin-bottom: 0; /* No extra margin on last paragraph */
        }

        /* Code Block Styles */
        .code-block {
            background-color: var(--code-bg);
            border-radius: var(--border-radius-sm);
            margin: 12px 0;
            overflow: hidden; /* Ensures rounded corners apply to content */
            box-shadow: var(--shadow);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2); /* Semi-transparent header */
            padding: 8px 16px; /* Increased padding */
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Subtle separator */
        }

        .code-language {
            font-weight: 500;
        }

        .code-header div {
            display: flex;
            gap: 8px; /* Space between buttons */
        }

        .copy-btn, .update-code-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 6px 12px; /* Adjusted padding */
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px; /* Space between icon and text */
        }

        .copy-btn:hover, .update-code-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        pre {
            background-color: var(--code-bg) !important;
            padding: 16px !important;
            margin: 0 !important; /* Remove margin from pre, it's on .code-block */
            overflow-x: auto;
            white-space: pre-wrap; /* Ensure code wraps */
        }

        code {
            font-family: 'Fira Code', monospace !important; /* Specific code font */
            font-size: 0.9rem !important;
            color: var(--code-text-color) !important;
        }

/* ================================
   ✅ Improved ChatGPT-like Input Area
================================== */

.input-area {
    padding: 16px 20px;
    background-color: var(--chat-bg);
    border-top: 1px solid rgba(0, 0, 0, 0.05);
    position: sticky;
    bottom: 0;
    z-index: 10;
}

.dark-mode .input-area {
    border-top-color: rgba(255, 255, 255, 0.05);
}

.input-container {
    display: flex;
    gap: 8px;
    width: 100%;
    max-width: 768px;
    margin: 0 auto;
    align-items: flex-end;
    position: relative;
    background: rgba(0, 0, 0, 0.03);
    border-radius: 28px;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    padding: 10px 14px;
    transition: box-shadow 0.2s ease;
}

.dark-mode .input-container {
    background: rgba(255, 255, 255, 0.05);
    box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.1);
}

.main.full-screen .input-container {
    max-width: 900px;
}

/* ✅ Improved Text Input */
#text-input {
    flex: 1;
    min-width: 0;
    padding: 10px 0;
    border: none;
    background: transparent;
    color: var(--text-color);
    font-size: 1rem;
    resize: none;
    overflow-y: auto;
    min-height: 28px;
    line-height: 1.5;
    max-height: 200px;
    border-radius: var(--border-radius-sm);
    transition: var(--transition);
    white-space: pre-wrap;
    word-wrap: break-word;
    scrollbar-width: thin;
    scrollbar-color: #10a37f transparent; /* Firefox support */
}

/* ✅ Custom Scrollbar Styling for WebKit (Chrome, Edge, Safari) */
#text-input::-webkit-scrollbar {
    width: 6px;
}

#text-input::-webkit-scrollbar-track {
    background: transparent;
}

#text-input::-webkit-scrollbar-thumb {
    background-color: #10a37f;   /* ✅ Green color */
    border-radius: 3px;
    border: 1px solid transparent;
}

#text-input::-webkit-scrollbar-thumb:hover {
    background-color: #0e8e6e;   /* Darker on hover */
}


#text-input:focus {
    outline: none;
}

.input-container:focus-within {
    box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.25), 
                inset 0 1px 2px rgba(0,0,0,0.05);
}
.dark-mode .input-container:focus-within {
    box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.25),
                inset 0 1px 2px rgba(255,255,255,0.1);
}

/* ✅ Bigger Icon Buttons */
.input-icon-btn,
.submit-btn,
.stop-btn {
    background: none;
    border: none;
    color: var(--text-light);
    cursor: pointer;
    font-size: 1.3rem;
    padding: 8px;
    border-radius: 50%;
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 42px;   /* Larger buttons */
    height: 42px;
    flex-shrink: 0;
}

.input-icon-btn:hover,
.submit-btn:hover {
    background: rgba(0, 0, 0, 0.05);
    color: var(--text-color);
}
.dark-mode .input-icon-btn:hover,
.dark-mode .submit-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-color);
}

/* Active Send Button */
.submit-btn.active {
    background-color: var(--primary-color);
    color: white;
}
.submit-btn.active:hover {
    background-color: #10837f;
}

/* Stop Button (visible when AI responds) */
.stop-btn {
    display: none;
    color: #ff6b6b;
}
.stop-btn:hover {
    background: rgba(255, 107, 107, 0.1);
}


        /* Image Preview in Input Area */
        .image-preview-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            margin-bottom: 10px;
            align-items: flex-start;
            position: relative;
        }
        .dark-mode .image-preview-container {
            border-color: rgba(255,255,255,0.1);
        }

        .image-preview-container img {
            max-width: 150px;
            max-height: 150px;
            border-radius: var(--border-radius-sm);
            object-fit: contain;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: var(--shadow);
        }
        .dark-mode .image-preview-container img {
            border-color: rgba(255,255,255,0.1);
        }

        .clear-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .clear-image-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        /* Responsive adjustments for input */
        @media (max-width: 768px) {
            .input-container {
                flex-wrap: nowrap; /* Keep on one line for mobile too */
                align-items: flex-end;
                padding-right: 5px;
                padding-left: 5px;
            }
            
            #text-input {
                flex: 1;
                min-height: 48px;
            }
            
            .input-icon-btn, .submit-btn, .stop-btn {
                width: 38px;
                height: 38px;
                padding: 8px;
            }

            /* Adjust spacing when voice mode is active */
            .input-container.voice-active #voice-talk-btn {
                order: 1;
                margin-right: 8px; /* Space between mic and indicator */
                margin-left: 0; /* Remove auto-margin */
            }

            .input-container.voice-active .voice-indicator-area {
                flex: 1 1 auto; /* Take remaining horizontal space */
                order: 2;
            }
            /* Hide full-screen toggle button on mobile */
            .top-bar-actions .full-screen-btn {
                display: none; 
            }
        }

        /* Loading Indicator */
        .loader {
            display: none; /* Hidden by default */
            padding: 16px;
            text-align: center;
            color: var(--text-color);
            font-size: 0.95rem;
            opacity: 0.7;
            animation: fadeIn 0.3s ease-in-out;
}

        .typing-indicator {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 6px;
        padding: 12px;
        height: 32px;
        animation: fadeIn 0.3s ease-in-out;
}

        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: var(--primary-color, #2563eb);
            border-radius: 50%;
            opacity: 0.4;
            animation: typingDotAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
        }

        @keyframes typingDotAnimation {
        0%, 80%, 100% {
            transform: scale(0.8);
            opacity: 0.4;
        }
        40% {
            transform: scale(1);
            opacity: 1;
        }
        }

        @keyframes fadeIn {
        from { opacity: 0; transform: translateY(5px); }
        to   { opacity: 1; transform: translateY(0); }
        }


        .typing-dot:nth-child(1) {
        animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
        }


        /* Enhanced Typing Animation */
        @keyframes typingAnimation {
            0%, 80%, 100% { transform: translateY(0); opacity: 0.4; }
            40% { transform: translateY(-8px); opacity: 1; } /* More pronounced bounce */
        }

        /* Special Message Components */
        .message-section {
            margin-bottom: 16px;
        }

        .section-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title i {
            font-size: 0.9rem;
        }

        .example-item {
            background: rgba(0, 0, 0, 0.05);
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid var(--primary-color);
            transition: var(--transition);
        }

        .example-item:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .dark-mode .example-item {
            background: rgba(255, 255, 255, 0.05);
        }

        .dark-mode .example-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .example-title {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .message-with-image {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message-images-container {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
        }

        .message-images-container img {
            max-width: 100%;
            max-height: 300px;
            border-radius: var(--border-radius-sm);
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: var(--shadow);
            object-fit: contain;
        }

        .dark-mode .message-images-container img {
            border-color: rgba(255,255,255,0.1);
        }

        .uploaded-image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: var(--border-radius-sm);
            margin-top: 10px;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: var(--shadow);
            object-fit: contain;
        }

        .dark-mode .uploaded-image-preview {
            border-color: rgba(255,255,255,0.1);
        }

        /* Camera Options (for mobile) */
        .camera-options {
            display: none; /* Hidden by default, shown on mobile for image upload */
            position: fixed;
            bottom: 80px; /* Position above the input area */
            left: 0;
            right: 0;
            background: var(--sidebar-bg); /* Use sidebar background for consistency */
            padding: 16px;
            border-radius: 16px 16px 0 0; /* Rounded top corners */
            box-shadow: 0 -5px 20px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideUp 0.3s ease-out; /* Slide up animation */
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .camera-option {
            padding: 14px;
            margin: 8px 0;
            background: var(--primary-color);
            color: white;
            border-radius: var(--border-radius-sm);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: 500;
            position: relative; /* For the hidden input */
            overflow: hidden; /* Hide the overflow of the input */
        }
        .camera-option:hover {
            background: var(--primary-light);
        }
        .camera-option.cancel {
            background: #ff6b6b; /* Red for cancel */
        }
        .camera-option.cancel:hover {
            background: #e65a5a;
        }

        /* Make hidden file inputs fill their parent .camera-option */
        .camera-option input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0; /* Make it completely transparent */
            cursor: pointer;
            z-index: 1; /* Ensure it's clickable above the div content */
        }


        /* Message Actions (e.g., Summarize) */
        .message-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: flex-end; /* Align actions to the right */
        }

        .message-action-btn {
            background: rgba(0,0,0,0.05); /* Light background for action buttons */
            color: var(--text-color);
            border: none;
            padding: 6px 12px;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 0.85rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dark-mode .message-action-btn {
            background: rgba(255, 255, 255, 0.1);
        }

        .message-action-btn:hover {
            background: rgba(0,0,0,0.1);
        }
        .dark-mode .message-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Confirmation Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000;
            top: 0; left: 0;
            width: 100%; height: 100%;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.2s ease-out;
        }

        .modal-content {
            background: var(--chat-bg);
            padding: 24px;
            border-radius: var(--border-radius);
            max-width: 90%;
            width: 400px;
            text-align: center;
            box-shadow: var(--shadow-md);
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: 16px;
            color: var(--text-color);
            font-size: 1.2rem;
        }

        .modal-content p {
            margin-bottom: 24px;
            color: var(--text-light);
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            flex: 1; /* Distribute space evenly */
            max-width: 120px; /* Max width for buttons */
        }

        .modal-btn.confirm {
            background-color: #ff6b6b; /* Red for destructive action */
            color: white;
        }

        .modal-btn.confirm:hover {
            background-color: #e65a5a;
        }

        .modal-btn.cancel {
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--text-color);
        }

        .dark-mode .modal-btn.cancel {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .modal-btn.cancel:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        .dark-mode .modal-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Full screen mode adjustments */
        body.full-screen-mode .sidebar {
            transform: translateX(-100%);
        }

        body.full-screen-mode .main {
            margin-left: 0;
            width: 100%;
        }

        body.full-screen-mode #showSidebarBtn {
            display: flex; /* Show floating button when in full screen */
        }

        /* Tooltip (general) */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); /* Tooltip background matches text color */
            color: white; /* Tooltip text matches background color */
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
            margin-bottom: 8px;
        }

        .tooltip-container:hover .tooltip {
            opacity: 1;
        }

        /* Gradient accent for some elements (if desired) */
        .gradient-accent {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
        }

        /* Pulse animation for new messages */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.01); } /* Subtle pulse */
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 0.5s ease;
        }
        /* Style for model selection radio buttons */
        .model-select-group {
            display: flex;
            justify-content: center;
            gap: 1.5rem; /* Increased gap for better spacing */
            margin-bottom: 1rem; /* Space below the radio buttons */
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05); /* Subtle separator */
        }
        .dark-mode .model-select-group {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .model-select-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.95rem; /* Slightly larger font */
            color: var(--text-color);
            transition: color 0.2s ease;
        }

        .model-select-group label:hover {
            color: var(--primary-color); /* Highlight on hover */
        }

        .model-select-group input[type="radio"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 18px; /* Custom radio button size */
            height: 18px;
            border: 2px solid var(--text-light); /* Border color */
            border-radius: 50%;
            margin-right: 8px;
            position: relative;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .model-select-group input[type="radio"]:checked {
            border-color: var(--primary-color); /* Primary color when checked */
            background-color: var(--primary-color);
        }

        .model-select-group input[type="radio"]:checked::before {
            content: '';
            display: block;
            width: 8px; /* Inner circle */
            height: 8px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Voice Indicator Area Styling (for input bar when in voice mode) */
        .voice-indicator-area {
            flex: 1; /* Take up the space of the text input */
            min-width: 0;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: transparent; /* Transparent background */
            border-radius: var(--border-radius-sm);
            min-height: 48px; /* Match button height */
            padding: 8px; /* Some padding */
            gap: 5px; /* Space between dots and text */
            /* Remove box-shadow from here, it's on the container now */
            transition: var(--transition);
        }

        .voice-indicator-area .typing-indicator {
            padding: 0; /* Remove padding from existing typing-indicator class */
        }

        #voice-status-text {
            font-size: 0.9rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Ensure voice indicator area is visible when voice-active class is present */
        .input-container.voice-active .voice-indicator-area {
            display: flex; /* Force display when voice is active */
        }

        /* Responsive adjustments for input-container when voice-indicator-area is active */
        @media (max-width: 768px) {
            .input-container.voice-active #voice-talk-btn {
                order: 1;
                margin-right: 8px; /* Space between mic and indicator */
                margin-left: 0; /* Remove auto-margin */
            }

            .input-container.voice-active .voice-indicator-area {
                flex: 1 1 auto; /* Take remaining horizontal space */
                order: 2;
            }
        }

        /* Desktop behavior for voice-indicator-area */
        @media (min-width: 769px) {
            .input-container.voice-active #voice-talk-btn {
                order: 1; /* Keep voice button visible and first */
            }

            .input-container.voice-active .voice-indicator-area {
                flex: 1; /* Take remaining space */
                order: 2; /* Place it after the voice button */
            }
        }

        /* NEW: Voice Mode Overlay Styles */
        #voice-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #202123; /* Dark background similar to ChatGPT */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            color: white;
            transition: opacity 0.3s ease;
            opacity: 0;
            pointer-events: none; /* Initially non-interactive */
        }

        #voice-mode-overlay.active {
            opacity: 1;
            pointer-events: auto; /* Make interactive when active */
        }

        #voice-mode-overlay .status-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            color: #a0a0a0; /* Lighter grey for status */
        }

        #voice-mode-overlay .control-buttons {
            position: absolute;
            bottom: 50px; /* Position at the bottom */
            display: flex;
            gap: 20px;
        }

        #voice-mode-overlay .control-button {
            background-color: #404040; /* Darker grey for buttons */
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.8rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        #voice-mode-overlay .control-button:hover {
            background-color: #555;
            transform: translateY(-2px);
        }

        #voice-mode-overlay .control-button.mic-active {
            background-color: var(--primary-color); /* Green when active */
        }
        #voice-mode-overlay .control-button.mic-active:hover {
            background-color: var(--primary-light);
        }

        #voice-mode-overlay .control-button.screen-share-active {
            background-color: #ff6b6b; /* Red for active screen share */
        }
        #voice-mode-overlay .control-button.screen-share-active:hover {
            background-color: #e65a5a;
        }

        #voice-circle-canvas {
            background-color: transparent; /* Canvas background */
            border-radius: 50%; /* Make it circular */
            /* Initial size, will be dynamic */
            width: 200px;
            height: 200px;
            max-width: 80vw; /* Responsive sizing */
            max-height: 80vw;
        }

        /* NEW: Screen Share Preview Container */
        #screen-share-preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Dark overlay */
            z-index: 999; /* Below voice mode overlay */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }

        #screen-share-preview-video {
            max-width: 90%;
            max-height: 90%;
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* NEW: Code Update Modal */
        #codeUpdateModal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Above other modals */
            top: 0; left: 0;
            width: 100%; height: 100%;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
        }

        #codeUpdateModal .modal-content {
            max-width: 800px;
            width: 90%;
            height: 80%;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        #codeUpdateModal textarea {
            flex: 1;
            width: 100%;
            min-height: 150px;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--text-light);
            border-radius: var(--border-radius-sm);
            background-color: var(--code-bg);
            color: var(--code-text-color);
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }

        #codeUpdateModal select {
            padding: 8px;
            margin-bottom: 15px;
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--text-light);
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        /* New CSS for ChatGPT-like talking animation (when AI is speaking) */
        #talking-animation {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px 18px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      color: white;
      font-size: 0.9rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out;
      z-index: 999;
    }

    #talking-animation.active {
      opacity: 1;
    }

    .talking-animation-bars {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .talking-bar {
      width: 4px;
      height: 16px;
      background-color: #10a37f;
      border-radius: 2px;
      transform-origin: bottom;
      animation: barWave 1.2s infinite ease-in-out;
      opacity: 0.7;
    }

    .talking-bar:nth-child(1) { animation-delay: 0s; }
    .talking-bar:nth-child(2) { animation-delay: 0.1s; }
    .talking-bar:nth-child(3) { animation-delay: 0.2s; }
    .talking-bar:nth-child(4) { animation-delay: 0.3s; }
    .talking-bar:nth-child(5) { animation-delay: 0.4s; }

    @keyframes barWave {
      0%, 100% { transform: scaleY(0.6); opacity: 0.5; }
      50% { transform: scaleY(1.4); opacity: 1; }
    }
    </style>
</head>
<body>

    <div id="talking-animation">
        Talking
        <div class="talking-animation-bars">
          <span class="talking-bar"></span>
          <span class="talking-bar"></span>
          <span class="talking-bar"></span>
          <span class="talking-bar"></span>
          <span class="talking-bar"></span>
        </div>
      </div>
      

    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo">
                <i class="fas fa-robot"></i>
                 <!-- <img src="vexara1.png" alt="V"> -->
                <span>Vexara</span>
            </div>
            <!-- Renamed hideSidebarBtn to sidebarToggleButton for general use -->
<!-- In your HTML -->
<button id="sidebarToggleButton" class="sidebar-toggle" title="Toggle Sidebar" aria-label="Toggle Sidebar">
    <i class="bx bx-layout"></i>
  </button>
  
        </div>

        <button class="new-chat-btn" onclick="startNewChat()" aria-label="Start New Chat">
            <i class="fi fi-rr-comment-alt-medical" style="font-size: 1.2rem;"></i>
            <span>New Chat</span>
        </button>

        <div id="chat-history-list" role="navigation" aria-label="Chat History"></div>

        <div class="sidebar-footer">
            <div id="user-info" class="user-info" style="display: none;" role="contentinfo">
                <i class="fas fa-user-circle" aria-hidden="true"></i>
                <span id="user-email" class="user-email"></span>
            </div>
            <button class="sidebar-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode" aria-label="Toggle Dark Mode">
                <i class="fas fa-moon" aria-hidden="true"></i>
                <span>Dark Mode</span>
            </button>
            <button class="sidebar-btn" id="clearAllChatsBtn" title="Clear All Chat History" aria-label="Clear All Chat History">
                <i class="fas fa-trash" aria-hidden="true"></i>
                <span>Clear All Chats</span>
            </button>
            <a href="/logout" class="sidebar-btn" style="color: #ff6b6b;" title="Logout" aria-label="Logout">
                <i class="fas fa-sign-out-alt" aria-hidden="true"></i>
                <span>Logout</span>
            </a>
        </div>
    </div>

    <!-- Floating button to show sidebar on mobile or in full screen mode -->
    <button id="showSidebarBtn" class="sidebar-show-btn" title="Show Sidebar" aria-label="Toggle Sidebar">
        <i class="fi fi-rr-sidebar"></i>
      </button>
      

    <div class="main">
        <div class="top-bar">
            <div class="top-bar-title">
                <!-- <i class="fas fa-robot" aria-hidden="true"></i> -->
                <span>Vexara</span>
            </div>
            <div class="top-bar-actions">
                <button class="action-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode" aria-label="Toggle Dark Mode">
                    <i class="fas fa-moon" aria-hidden="true"></i>
                </button>
                
            </div>
        </div>

        <div class="chat-container" id="chatbox" role="log" aria-live="polite">
            <!-- Initial New Chat Placeholder -->
            <div id="new-chat-placeholder" class="new-chat-placeholder">
                <!-- <i class="fas fa-robot logo-large" aria-hidden="true"></i> -->
                <span class="title">What are you working on?</span>
                <p>Welcome to Vexara! How can I assist you today?</p>
            </div>
        </div>

        <!-- Input Area at the bottom -->
        <div class="input-area">
            <!-- Image Preview Container -->
            <div id="image-preview-container" class="image-preview-container" aria-live="polite" aria-atomic="true">
                <img id="image-preview" src="#" alt="Image Preview" style="display: none;">
                <button id="clear-image-btn" class="clear-image-btn" title="Clear Image" aria-label="Clear Image Preview">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>

            <form id="multi-action-form" enctype="multipart/form-data">
                <!-- Model Selection Radio Buttons -->
                <div class="model-select-group" role="radiogroup" aria-label="Select AI Model">
                    <label for="modelGeneral">
                        <input type="radio" id="modelGeneral" name="modelChoice" value="general" checked aria-checked="true">
                        General Talk (Mistral)
                    </label>
                    <label for="modelDeepThink">
                        <input type="radio" id="modelDeepThink" name="modelChoice" value="deep_think" aria-checked="false">
                        Deep Think (DeepSeek)
                    </label>
                </div>

                <div class="input-container">
                    <!-- Icons on the left -->
                    <button type="button" class="input-icon-btn" id="attach-file-btn" title="Attach File" aria-label="Attach File">
                        <i class="fas fa-paperclip" aria-hidden="true"></i>
                    </button>
                    <!-- Hidden file input, now outside the button for precise control -->
                    <input type="file" id="desktop-file-input" name="image" accept="image/*" style="display: none;" aria-label="Upload image file"/>

                    <button type="button" id="web-search-btn" class="input-icon-btn" title="Web Search" aria-label="Perform Web Search">
                        <i class="fas fa-globe" aria-hidden="true"></i>
                    </button>

                    <!-- Main Textarea -->
                    <textarea id="text-input" name="instruction" placeholder="Ask anything" rows="1" required aria-label="Type your message here"></textarea>
                    
                    <!-- Voice Indicator Area (for input bar when not in full voice mode) -->
                    <div id="voice-indicator-area" class="voice-indicator-area" aria-live="polite" aria-atomic="true">
                        <div class="typing-indicator">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                        <span id="voice-status-text"></span>
                    </div>

                    <!-- Voice Talk Button (on the right, before send) -->
                    <button type="button" id="voice-talk-btn" class="input-icon-btn" title="Toggle Voice Talk" aria-label="Toggle Voice Talk">
                        <i class="fas fa-microphone" aria-hidden="true"></i>
                    </button>
                
                    <!-- Send/Stop Buttons (on the far right) -->
                    <button type="submit" class="submit-btn" id="send-btn" title="Send Message" aria-label="Send Message">
                        <i class="fa-solid fa-arrow-up"></i>
                    </button>
                    <button type="button" class="stop-btn" id="stop-btn" title="Stop Response" aria-label="Stop AI Response">
                        <i class="fas fa-stop" aria-hidden="true"></i>
                    </button>
                </div>
            </form>
        </div>

        <!-- Loading Indicator -->
        <div class="loader" id="loader" aria-live="polite" aria-atomic="true" style="display: none;">
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
    </div>

    <!-- NEW: Voice Mode Full-Screen Overlay -->
    <div id="voice-mode-overlay" role="dialog" aria-modal="true" aria-label="Voice Interaction Mode">
        <div class="status-text">Standard voice</div>
        <canvas id="voice-circle-canvas" role="img" aria-label="Voice Activity Visualizer"></canvas>
        <div class="control-buttons">
            <button id="mic-control-btn" class="control-button" aria-label="Toggle Microphone">
                <i class="fas fa-microphone" aria-hidden="true"></i>
            </button>
            <button id="screen-share-btn" class="control-button" title="Toggle Screen Share" aria-label="Toggle Screen Share">
                <i class="fas fa-desktop" aria-hidden="true"></i>
            </button>
            <button id="close-voice-mode-btn" class="control-button" aria-label="Close Voice Mode">
                <i class="fas fa-times" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <!-- NEW: Screen Share Preview Container -->
    <div id="screen-share-preview-container" role="dialog" aria-modal="true" aria-label="Screen Share Preview">
        <video id="screen-share-preview-video" autoplay aria-label="Screen Share Video Feed"></video>
    </div>

    <!-- Confirmation Modal for Clear All Chats -->
    <div id="confirmModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalDescription">
        <div class="modal-content">
            <h3 id="modalTitle">Clear All Chats?</h3>
            <p id="modalDescription">Are you sure you want to clear all chat history? This action cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="hideModal()" aria-label="Cancel">Cancel</button>
                <button class="modal-btn confirm" id="confirmClearBtn" aria-label="Confirm Clear All">Clear All</button>
            </div>
        </div>
    </div>

    <!-- NEW: Code Update Modal -->
    <div id="codeUpdateModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="codeUpdateModalTitle">
        <div class="modal-content">
            <h3 id="codeUpdateModalTitle">Update Code File</h3>
            <p>Paste the updated code below. Select the file to update (e.g., `index.html` or `test.py`).</p>
            <select id="fileToUpdateSelect" aria-label="Select file to update">
                <option value="index.html">index.html (Frontend HTML/JS)</option>
                <option value="test.py">test.py (Backend Python)</option>
                <option value="script.py">script.py (Backend Python - if applicable)</option>
            </select>
            <textarea id="codeUpdateTextarea" placeholder="Paste your updated code here..." aria-label="Code to update"></textarea>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="document.getElementById('codeUpdateModal').style.display='none';" aria-label="Cancel">Cancel</button>
                <button class="modal-btn confirm" id="applyCodeUpdateBtn" aria-label="Apply Code Update">Apply Update</button>
            </div>
        </div>
    </div>

    <!-- Camera Options (for mobile file upload) -->
    <div class="camera-options" role="dialog" aria-modal="true" aria-label="Choose Image Source">
        <div class="camera-option" id="take-photo" tabindex="0" role="button" aria-label="Take Photo">
            <i class="fas fa-camera" aria-hidden="true"></i>
            <span>Take Photo</span>
            <!-- Hidden input directly inside the clickable area -->
            <input type="file" id="take-photo-input" name="image" accept="image/*" capture="environment" style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; z-index: 1;"/>
        </div>
        <div class="camera-option" id="upload-photo" tabindex="0" role="button" aria-label="Choose from Gallery">
            <i class="fas fa-images" aria-hidden="true"></i>
            <span>Choose from Gallery</span>
            <!-- Hidden input directly inside the clickable area -->
            <input type="file" id="upload-photo-input" name="image" accept="image/*" style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; z-index: 1;"/>
        </div>
        <div class="camera-option cancel" id="cancel-camera" tabindex="0" role="button" aria-label="Cancel">
            <i class="fas fa-times" aria-hidden="true"></i>
            <span>Cancel</span>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.0/marked.min.js"></script>
    <script>
        // Global variables for chat management
        let currentChatId = null;
        let sidebarHidden = false; // Tracks if sidebar is manually collapsed on desktop
        let isFullScreen = false; // Tracks if full screen chat mode is active
        let abortController = null; // Global AbortController for stopping AI responses

        // Voice Talk Globals
        let recognition;
        let synth = window.speechSynthesis;
        let isVoiceTalkActive = false; // Controls the full-screen voice overlay
        let isListening = false; // Controls SpeechRecognition state
        let isSpeaking = false; // Controls SpeechSynthesis state
        let pendingBotSpeechText = ""; // Global to hold the actual text that will be displayed after speaking
        let speechQueue = []; // Queue for streaming speech synthesis
        let isProcessingSpeechQueue = false; // Flag to manage speech queue processing
        let selectedVoice = null; // Stores the selected voice for AI speech

        // Web Audio API for visualizer
        let audioContext;
        let analyser;
        let microphoneStream;
        let animationFrameId;
        let canvas, canvasCtx;
        let bufferLength;
        let dataArray;
        // let aiVoiceSource; // Not directly used as SpeechSynthesis doesn't expose an audio source node

        // Screen Share Globals
        let screenShareStream = null;
        let screenShareInterval = null;
        let isScreenSharing = false;
        const screenCaptureCanvas = document.createElement('canvas'); // Off-screen canvas
        const screenCaptureCtx = screenCaptureCanvas.getContext('2d');
        const screenShareVideoElement = document.getElementById('screen-share-preview-video');
        const screenSharePreviewContainer = document.getElementById('screen-share-preview-container');

        // Helper Functions
        function scrollToBottom() {
            const chatbox = document.getElementById('chatbox');
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        // Function to escape HTML entities for display within a text area or code block
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Custom Marked.js Renderer for Code Blocks
        const renderer = new marked.Renderer();
        renderer.code = function(code, lang, escaped) {
            const language = lang || 'plaintext';
            // The 'code' parameter here is already unescaped by marked.js.
            // We need to re-escape it to ensure it's displayed as raw text within <pre><code>.
            const codeToDisplay = escapeHtml(code); 

            // Determine if the code is likely HTML or Python for file update purposes
            let fileType = 'txt';
            if (language.toLowerCase() === 'html' || language.toLowerCase() === 'javascript' || language.toLowerCase() === 'css') {
                fileType = 'index.html'; // Default to index.html for frontend code
            } else if (language.toLowerCase() === 'python') {
                fileType = 'test.py'; // Default to test.py for backend code
            }

            return `
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">${language.toUpperCase()}</span>
                        <div>
                            <button class="copy-btn" onclick="copyToClipboard(this)" aria-label="Copy code to clipboard">
                                <i class="far fa-copy" aria-hidden="true"></i> Copy
                            </button>
                            <button class="update-code-btn" onclick="openCodeUpdateModal(\`${codeToDisplay.replace(/`/g, '\\`')}\`, '${fileType}')" aria-label="Update code file">
                                <i class="fas fa-code" aria-hidden="true"></i> Update
                            </button>
                        </div>
                    </div>
                    <pre><code class="language-${language}">${codeToDisplay}</code></pre>
                </div>
            `;
        };
        // Override for paragraph rendering to add default margins
        renderer.paragraph = function(text) {
            return `<p>${text}</p>`;
        };

        marked.setOptions({
            breaks: true, // Allow GFM line breaks
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language }).value;
            },
            renderer: renderer // Use our custom renderer
        });

        // Function to copy code to clipboard
        window.copyToClipboard = function(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            if (codeBlock) {
                const textToCopy = codeBlock.textContent || codeBlock.innerText;

                // Create a temporary textarea element to hold the text
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                tempTextArea.style.position = 'fixed'; // Prevent scrolling to bottom of page
                tempTextArea.style.left = '-9999px'; // Move off-screen
                tempTextArea.style.top = '0';
                document.body.appendChild(tempTextArea);

                // Select the text in the textarea
                tempTextArea.focus();
                tempTextArea.select();

                try {
                    // Execute the copy command
                    const successful = document.execCommand('copy');
                    if (successful) {
                        button.innerHTML = '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy" aria-hidden="true"></i> Copy';
                        }, 2000);
                    } else {
                        // Fallback for modern browsers if execCommand fails (e.g., due to restrictions)
                        // This part might still fail in strict iframe environments, but it's the standard fallback.
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            button.innerHTML = '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
                            setTimeout(() => {
                                button.innerHTML = '<i class="far fa-copy" aria-hidden="true"></i> Copy';
                            }, 2000);
                        }).catch(err => {
                            console.error('Failed to copy text using navigator.clipboard:', err);
                            // Provide user feedback if both methods fail
                            button.innerHTML = '<i class="fas fa-times" aria-hidden="true"></i> Failed';
                            setTimeout(() => {
                                button.innerHTML = '<i class="far fa-copy" aria-hidden="true"></i> Copy';
                            }, 2000);
                        });
                    }
                } catch (err) {
                    console.error('Failed to copy text using document.execCommand:', err);
                    // Fallback to navigator.clipboard if execCommand throws an error
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        button.innerHTML = '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy" aria-hidden="true"></i> Copy';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text using navigator.clipboard (fallback):', err);
                        button.innerHTML = '<i class="fas fa-times" aria-hidden="true"></i> Failed';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy" aria-hidden="true"></i> Copy';
                        }, 2000);
                    });
                } finally {
                    // Clean up the temporary textarea
                    document.body.removeChild(tempTextArea);
                }
            }
        };

        // Function to add a new message to the chatbox
        function addMessage(text, type = 'bot', optionalContent = null, timestamp = new Date()) {
            const chatbox = document.getElementById('chatbox');
            const newChatPlaceholder = document.getElementById('new-chat-placeholder');
            if (newChatPlaceholder) {
                newChatPlaceholder.remove(); // Remove placeholder once messages start
            }

            const msg = document.createElement('div');
            msg.className = `chat-message ${type}-message pulse`; // Add pulse animation class
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.innerHTML = type === 'user' ? 'You' : 'Vexara';
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            // header.appendChild(timestampSpan);
            // msg.appendChild(header);
            
            const content = document.createElement('div');
            content.className = 'message-content';
            // Warn if text content is unexpectedly empty for user messages
            if (type === 'user' && !text.trim()) {
                console.warn("User message text is empty. This might indicate an issue with backend message storage.");
                content.innerHTML = "*(No text provided)*"; // Placeholder for empty text
            } else {
                content.innerHTML = marked.parse(text); // Parse markdown content
            }
            msg.appendChild(content);

            // Append optional content (e.g., uploaded image or generated images)
            if (optionalContent) {
                if (optionalContent instanceof HTMLElement) {
                    msg.appendChild(optionalContent);
                } else if (Array.isArray(optionalContent)) {
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'message-images-container';
                    optionalContent.forEach(imageUrl => {
                        const imgElement = document.createElement('img');
                        imgElement.src = imageUrl;
                        imgElement.alt = "Generated Image";
                        imageContainer.appendChild(imgElement);
                    });
                    msg.appendChild(imageContainer);
                }
            }
            
            chatbox.appendChild(msg);
            scrollToBottom();

            // Highlight code blocks after adding message
            document.querySelectorAll('.chat-message code').forEach((block) => {
                try {
                    hljs.highlightElement(block);
                } catch (e) {
                    console.warn("Highlight.js failed on block:", block, e);
                    block.style.color = 'var(--code-text-color)'; 
                }
            });
        }

        // Function to simulate typing effect for bot messages
        // This function is now responsible for creating the initial message container
        // and updating its content as chunks arrive.
        let currentBotMessageElement = null; // Reference to the current bot message being typed
        let currentBotMessageContentDiv = null; // Reference to the content div within that message
        let currentBotMessageFullText = ""; // Accumulates the full text for saving/actions

        // Global/module-level declaration for sentence detector
        const sentenceRegex = /[^.!?]+[.!?]+/g; // Moved to global scope

        function createStreamingBotMessage(timestamp = new Date()) {
            const chatbox = document.getElementById('chatbox');
            const newChatPlaceholder = document.getElementById('new-chat-placeholder');
            if (newChatPlaceholder) {
                newChatPlaceholder.remove(); // Remove placeholder once messages start
            }

            const msg = document.createElement('div');
            msg.className = `chat-message bot-message`; // No pulse on typing init
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.innerHTML = 'Vexara';
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            header.appendChild(timestampSpan);
            msg.appendChild(header);

            currentBotMessageContentDiv = document.createElement('div');
            currentBotMessageContentDiv.className = 'message-content';
            msg.appendChild(currentBotMessageContentDiv);

            chatbox.appendChild(msg);
            scrollToBottom();

            currentBotMessageElement = msg; // Store reference to the new message element
            currentBotMessageFullText = ""; // Reset full text accumulator
            pendingBotSpeechText = ""; // Ensure pending speech text is cleared for new message
            sentenceRegex.lastIndex = 0; // Reset regex state for new message
        }

        async function appendToStreamingBotMessage(chunk) {
            if (!currentBotMessageContentDiv) {
                console.error("No active bot message element to append to.");
                return;
            }

            currentBotMessageFullText += chunk;

            // If voice talk is active, try to speak chunks as sentences
            if (isVoiceTalkActive) {
                pendingBotSpeechText += chunk;
                let lastSpokenIndex = 0; // Track the end index of the last spoken sentence
                
                // Reset lastIndex for each new processing cycle of pendingBotSpeechText
                // This is crucial because pendingBotSpeechText is modified.
                sentenceRegex.lastIndex = 0; 
                let match;
                
                // Loop to find all complete sentences in the current pendingBotSpeechText
                while ((match = sentenceRegex.exec(pendingBotSpeechText)) !== null) {
                    const sentence = match[0].trim();
                    if (sentence) {
                        speakText(sentence);
                        lastSpokenIndex = sentenceRegex.lastIndex; // Store the index up to which we've spoken
                    }
                }

                // Remove the spoken sentences from the beginning of pendingBotSpeechText
                if (lastSpokenIndex > 0) {
                    pendingBotSpeechText = pendingBotSpeechText.substring(lastSpokenIndex);
                }
                // No need to reset sentenceRegex.lastIndex here, it will be reset at the start of the next call.

            } 
            // Always update innerHTML with parsed Markdown for immediate visual feedback
            currentBotMessageContentDiv.innerHTML = marked.parse(currentBotMessageFullText);
            
            currentBotMessageContentDiv.querySelectorAll('pre code').forEach((block) => {
                try {
                    hljs.highlightElement(block);
                } catch (e) {
                    console.warn("Highlight.js failed on block during streaming:", block, e);
                    block.style.color = 'var(--code-text-color)'; 
                }
            });
            
            scrollToBottom();
        }

        async function finalizeStreamingBotMessage(image_urls = []) {
            if (!currentBotMessageElement) {
                console.error("No active bot message element to finalize.");
                return;
            }

            // Speak any remaining pending text if voice talk is active
            if (isVoiceTalkActive && pendingBotSpeechText) {
                await new Promise(resolve => {
                    const finalUtterance = new SpeechSynthesisUtterance(pendingBotSpeechText);
                    finalUtterance.lang = 'en-US';
                    finalUtterance.pitch = 1.0; // Default pitch
                    finalUtterance.rate = 1.0; // Default rate
                    finalUtterance.voice = selectedVoice; // Apply selected voice
                    finalUtterance.onend = resolve;
                    finalUtterance.onerror = resolve; // Resolve even on error to finalize message
                    synth.speak(finalUtterance);
                });
            }

            // Ensure the content is displayed if it wasn't during streaming (e.g., voice mode was active)
            // This will re-render the entire message with full Markdown parsing and highlighting.
            if (currentBotMessageContentDiv && currentBotMessageFullText) { // Check if full text exists
                currentBotMessageContentDiv.innerHTML = marked.parse(currentBotMessageFullText);
                currentBotMessageContentDiv.querySelectorAll('pre code').forEach((block) => {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        console.warn("Highlight.js failed on block during streaming (finalize):", block, e);
                        block.style.color = 'var(--code-text-color)'; 
                    }
                });
            }

            // Append images
            if (image_urls && image_urls.length > 0) {
                const imageContainer = document.createElement('div');
                imageContainer.className = 'message-images-container';
                image_urls.forEach(imageUrl => {
                    const imgElement = document.createElement('img');
                    imgElement.src = imageUrl;
                    imgElement.alt = "Generated Image";
                    imageContainer.appendChild(imgElement);
                });
                currentBotMessageElement.appendChild(imageContainer);
                scrollToBottom();
            }

            // Add action buttons
            if (currentBotMessageFullText.length > 100) {
                const messageActionsDiv = document.createElement('div');
                messageActionsDiv.className = 'message-actions';

                const summarizeButton = document.createElement('button');
                summarizeButton.className = 'message-action-btn';
                summarizeButton.innerHTML = '<i class="fas fa-sparkle" aria-hidden="true"></i> Summarize';
                summarizeButton.onclick = async () => {
                    summarizeButton.disabled = true;
                    summarizeButton.innerHTML = '<i class="fas fa-hourglass-half" aria-hidden="true"></i> Summarizing...';
                    const summary = await summarizeText(currentBotMessageFullText);
                    if (summary) {
                        addMessage(`**Summary:** ${summary}`, 'bot', null, new Date());
                    }
                    summarizeButton.disabled = false;
                    summarizeButton.innerHTML = '<i class="fas fa-sparkle" aria-hidden="true"></i> Summarize';
                };
                messageActionsDiv.appendChild(summarizeButton);
                currentBotMessageElement.appendChild(messageActionsDiv);
            }

            // Clear references
            currentBotMessageElement = null;
            currentBotMessageContentDiv = null;
            currentBotMessageFullText = "";
            pendingBotSpeechText = ""; // Ensure this is cleared here too
            sentenceRegex.lastIndex = 0; // Ensure regex state is reset on finalization
            scrollToBottom(); // Final scroll to ensure everything is visible

            // If voice mode is active, restart listening after AI finishes speaking
            if (isVoiceTalkActive) {
                startListening();
            }
        }


        // AI Function Calls (stubs, assume backend handles actual API calls)
        async function askAI(instruction, modelChoice, performSearch = false) { // Added performSearch parameter
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');

            // Show loader BEFORE creating the streaming message
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button, hide send button
            stopSpeaking(); // Stop AI speech if any

            // Initialize AbortController for this request
            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('instruction', instruction);
                formData.append('chat_id', currentChatId);
                formData.append('model_choice', modelChoice); // Append model choice
                formData.append('web_search', performSearch); // Pass the web_search flag

                const response = await fetch(`${window.location.origin}/ask`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal to the fetch request
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                // Hide loader once the actual streaming starts
                loader.style.display = 'none'; 

                // Create the initial message container for streaming
                createStreamingBotMessage(new Date());

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;

                while (!done) {
                    const { value, done: readerDone } = await reader.read();
                    done = readerDone;
                    const chunk = decoder.decode(value, { stream: true });
                    if (chunk) {
                        await appendToStreamingBotMessage(chunk);
                    }
                }
                
                // Finalize the streaming message after stream finishes
                finalizeStreamingBotMessage(); 

            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Fetch aborted by user.');
                    if (currentBotMessageContentDiv) {
                        currentBotMessageContentDiv.innerHTML += `<p>*(Response stopped by user)*</p>`;
                    } else {
                        addMessage(`Response stopped by user.`, 'bot', null, new Date());
                    }
                } else {
                    console.error("Error asking AI:", error);
                    // If an error occurs, ensure the message is still added or updated
                    if (currentBotMessageContentDiv) {
                        currentBotMessageContentDiv.innerHTML += `<p>Error: ${error.message}</p>`;
                    } else {
                        addMessage(`Sorry, there was an error processing your request: ${error.message}. Please try again.`, 'bot', null, new Date());
                    }
                }
                finalizeStreamingBotMessage(); // Attempt to finalize even on error
            } finally {
                textInput.value = ''; 
                textInput.style.height = 'auto'; // Reset textarea height
                textInput.focus();
                showSendButton(); // Show send button, hide stop button
                abortController = null; // Clear the controller
            }
        }

        async function generateImage(prompt) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;
            
            try {
                const formData = new FormData();
                formData.append('instruction', prompt); 
                formData.append('chat_id', currentChatId); 

                const response = await fetch(`${window.location.origin}/generate_image`, { 
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();

                loader.style.display = 'none';

                if (data.image_urls && data.image_urls.length > 0) {
                    addMessage(data.response, 'bot', data.image_urls, new Date()); 
                    if (isVoiceTalkActive && data.response) speakText(data.response);
                } else {
                    addMessage(data.response, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.response) speakText(data.response);
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Image generation aborted by user.');
                    addMessage(`Image generation stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, there was an error generating the image: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto'; 
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        async function uploadImage(file, caption) {
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; // Show loader for upload
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('image', file);
                if (caption) {
                    formData.append('caption', caption);
                }
                formData.append('chat_id', currentChatId); 

                const response = await fetch(`${window.location.origin}/upload_image`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json(); 
                
                loader.style.display = 'none'; // Hide loader after response
                if (data && data.response) {
                    // Assuming the backend has already saved the user's message (caption + image) correctly.
                    // Now, display the AI's response (which might contain extracted text) as a separate bot message.
                    if (data.image_urls && data.image_urls.length > 0) {
                        addMessage(data.response, 'bot', data.image_urls, new Date());
                        if (isVoiceTalkActive && data.response) speakText(data.response);
                    } else {
                        addMessage(data.response, 'bot', null, new Date());
                        if (isVoiceTalkActive && data.response) speakText(data.response);
                    }
                } else {
                    console.error("Image upload failed: Received an empty response or no AI response."); 
                    addMessage("Received an empty response from the server after image upload. Please try again.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Image upload aborted by user.');
                    addMessage(`Image upload stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Failed to upload image due to network error: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                clearImagePreview(); // Clear preview in all cases
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        // --- DEPRECATED: performWebSearch is no longer directly called from frontend for display ---
        // It's kept here for reference but the logic is now handled by askAI with web_search flag
        /*
        async function performWebSearch(query) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            const BACKEND_WEB_SEARCH_ENDPOINT = `${window.location.origin}/web_search`; 

            try {
                const response = await fetch(BACKEND_WEB_SEARCH_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ q: query, chat_id: currentChatId }),
                    signal: signal // Pass the abort signal
                });

                if (!response.ok) {
                    let errorMessage = `Web search failed with status ${response.status}`;

                    try {
                        const cloned = response.clone(); // Clone the stream
                        const errorData = await cloned.json();
                        if (errorData?.error) {
                            errorMessage = `Web search failed: ${errorData.error}`;
                        }
                    } catch (e) {
                        try {
                            const fallbackCloned = response.clone(); // Clone again to read text
                            const text = await fallbackCloned.text();
                            if (text && text.startsWith('<')) {
                                errorMessage = "Server returned an HTML error page. Check if your backend route returns JSON.";
                            } else {
                                errorMessage = `Unexpected error response: ${text}`;
                            }
                        } catch (finalError) {
                            errorMessage = `Could not read error body: ${finalError.message}`;
                        }
                    }

                    throw new Error(errorMessage);
                }

                const data = await response.json();
                loader.style.display = 'none';

                // The backend now sends the formatted response directly in data.response
                const botResponseText = data.response; 
                
                addMessage(botResponseText, 'bot', null, new Date()); // Use addMessage for non-streaming
                if (isVoiceTalkActive && botResponseText) speakText(botResponseText);

            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Web search aborted by user.');
                    addMessage(`Web search stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, there was an error performing the web search: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }
        */
        // --- END DEPRECATED: Web Search Functionality ---

        async function summarizeText(textToSummarize) {
            try {
                const response = await fetch(`${window.location.origin}/summarize_text`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: textToSummarize, chat_id: currentChatId }), 
                });
                const data = await response.json();
                if (data && data.summary) {
                    return data.summary;
                } else {
                    console.error("Summarization failed:", data.error || "No summary returned.");
                    return null;
                }
            } catch (error) {
                console.error("Error summarizing text:", error);
                return null;
            }
        }

        async function checkGrammarAndStyle(text) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block';
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('text', text);
                formData.append('chat_id', currentChatId);

                const response = await fetch(`${window.location.origin}/check_grammar_style`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();
                loader.style.display = 'none';
                if (data && data.corrected_text) {
                    addMessage(data.corrected_text, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.corrected_text) speakText(data.corrected_text);
                } else {
                    console.error("Grammar/Style check failed:", data.error || "No response returned.");
                    addMessage(data.error || "Failed to check grammar and style.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Grammar check aborted by user.');
                    addMessage(`Grammar check stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, an error occurred while checking the grammar and style: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        async function explainCode(code) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block';
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('code', code);
                formData.append('chat_id', currentChatId);

                const response = await fetch(`${window.location.origin}/explain_code`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();
                loader.style.display = 'none';
                if (data && data.explanation) {
                    addMessage(data.explanation, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.explanation) speakText(data.explanation);
                } else {
                    console.error("Code explanation failed:", data.error || "No response returned.");
                    addMessage(data.error || "Failed to explain code.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Code explanation aborted by user.');
                    addMessage(`Code explanation stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, an error occurred while explaining the code: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        // UI Functions
        function showModal() {
            document.getElementById('confirmModal').style.display = 'flex';
        }

        function hideModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }
        
        // Show image preview in the input area
        function showImagePreview(file) {
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const imagePreview = document.getElementById('image-preview');
            const clearImageBtn = document.getElementById('clear-image-btn');

            const reader = new FileReader();
            reader.onload = function(e) {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                imagePreviewContainer.style.display = 'flex';
                clearImageBtn.style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }

        // Clear image preview from the input area
        function clearImagePreview() {
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const imagePreview = document.getElementById('image-preview');
            const clearImageBtn = document.getElementById('clear-image-btn');
            const takePhotoInput = document.getElementById('take-photo-input'); // Get new inputs
            const uploadPhotoInput = document.getElementById('upload-photo-input');
            const desktopFileInput = document.getElementById('desktop-file-input'); // NEW: Get desktop input

            imagePreview.src = '#';
            imagePreview.style.display = 'none';
            imagePreviewContainer.style.display = 'none';
            clearImageBtn.style.display = 'none';
            if (takePhotoInput) takePhotoInput.value = ''; // Clear file inputs
            if (uploadPhotoInput) uploadPhotoInput.value = '';
            if (desktopFileInput) desktopFileInput.value = ''; // NEW: Clear desktop file input
        }

        // Toggle full screen mode
        window.toggleFullScreen = function() {
            const body = document.body;
            isFullScreen = !isFullScreen;
            
            if (isFullScreen) {
                body.classList.add('full-screen-mode');
            } else {
                body.classList.remove('full-screen-mode');
                // Restore sidebar visibility based on previous state if on desktop
                if (window.innerWidth > 768 && !sidebarHidden) {
                    document.getElementById('sidebar').classList.remove('collapsed');
                    document.querySelector('.main').classList.remove('full-width');
                }
            }
            // Ensure the correct sidebar toggle button is shown/hidden after full screen toggle
            updateSidebarToggleButtonVisibility();
        };

        window.clearAllChats = function() {
            showModal();
        };

        window.startNewChat = async function(isInitialLoad = false) {
            const chatbox = document.getElementById('chatbox');
            const textInput = document.getElementById('text-input');
            const modelGeneralRadio = document.getElementById('modelGeneral'); // Get radio button
            const newChatPlaceholder = document.getElementById('new-chat-placeholder');

            try {
                const response = await fetch(`${window.location.origin}/start_new_chat`, { method: 'POST' });
                const data = await response.json();
                if (data.chat_id) {
                    currentChatId = data.chat_id;
                    chatbox.innerHTML = ''; // Clear chatbox
                    // Re-add the placeholder if it's a new chat and no messages are loaded yet
                    if (!newChatPlaceholder) { // Only add if it doesn't exist
                        const placeholderDiv = document.createElement('div');
                        placeholderDiv.id = 'new-chat-placeholder';
                        placeholderDiv.className = 'new-chat-placeholder';
                        placeholderDiv.innerHTML = `
                            
                    
                            <span class="title">What are you working on?</span>
                            <p>Welcome to Vexara! How can I assist you today?</p>
                        `;
                        chatbox.appendChild(placeholderDiv);
                    }
                    
                    textInput.value = '';
                    textInput.style.height = 'auto';
                    textInput.focus();
                    textInput.setAttribute('required', '');
                    textInput.placeholder = 'Ask anything'; // Updated placeholder for new chat
                    clearImagePreview(); // Clear any existing image preview
                    modelGeneralRadio.checked = true; // Set General Talk as default on new chat
                    
                    // Removed the "New chat started" message as it's replaced by the placeholder
                   
                    await updateChatHistory();
                } else {
                    console.error("Failed to get a new chat ID from backend.");
                    addMessage("Failed to start new chat. Please try refreshing the page.", 'bot', null, new Date());
                }
            } catch (error) {
                console.error("Error starting new chat:", error);
                addMessage("Failed to start new chat due to network error. Please try again.", 'bot', null, new Date());
            }
        };

        window.toggleDarkMode = function() {
            document.body.classList.toggle('dark-mode');
            if (document.body.classList.contains('dark-mode')) {
                localStorage.setItem('darkMode', 'enabled');
            } else {
                localStorage.removeItem('darkMode');
            }
        };

        // Handles sidebar visibility for both desktop collapse and mobile slide-out
        window.toggleSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.querySelector('.main');
            
            if (window.innerWidth <= 768 || isFullScreen) { // Mobile or Full Screen mode
                sidebar.classList.toggle('visible');
            } else { // Desktop
                sidebar.classList.toggle('collapsed');
                mainContent.classList.toggle('full-width');
                sidebarHidden = sidebar.classList.contains('collapsed'); // Update hidden state
            }
            updateSidebarToggleButtonVisibility(); // Update button visibility after toggling
        };

        // Helper function to manage sidebar toggle button visibility
        function updateSidebarToggleButtonVisibility() {
            const sidebar = document.getElementById('sidebar');
            const showSidebarBtn = document.getElementById('showSidebarBtn');
            const sidebarToggleButton = document.getElementById('sidebarToggleButton'); // The button inside the sidebar

            if (window.innerWidth <= 768 || isFullScreen) { // Mobile or Full Screen mode
            if (sidebar.classList.contains('visible')) {
                showSidebarBtn.style.display = 'none';
                sidebarToggleButton.style.display = 'block';
                sidebarToggleButton.querySelector('i').className = 'fi fi-rr-sidebar'; // Same icon
            } else {
                showSidebarBtn.style.display = 'flex';
                sidebarToggleButton.style.display = 'none';
                showSidebarBtn.querySelector('i').className = 'fi fi-rr-sidebar'; // Same icon
            }
        } else { // Desktop
            if (sidebar.classList.contains('collapsed')) {
                showSidebarBtn.style.display = 'flex'; // Show floating button to expand
                sidebarToggleButton.style.display = 'none'; // Hide internal toggle
                showSidebarBtn.querySelector('i').className = 'fi fi-rr-sidebar'; // Same icon
            } else {
                showSidebarBtn.style.display = 'none'; // Hide floating button
                sidebarToggleButton.style.display = 'block'; // Show internal toggle
                sidebarToggleButton.querySelector('i').className = 'fi fi-rr-sidebar'; // Same icon
            }
        }
    }



        // Functions to toggle visibility of Send and Stop buttons
        function showSendButton() {
            if (isVoiceTalkActive) return; // Do not show if voice talk is active
            document.getElementById('send-btn').style.display = 'flex';
            document.getElementById('stop-btn').style.display = 'none';
        }

        function showStopButton() {
            if (isVoiceTalkActive) return; // Do not show if voice talk is active
            document.getElementById('send-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'flex';
        }

        // NEW: Functions for the subtle talking animation
        function showTalkingAnimation() {
            const talkingAnimation = document.getElementById("talking-animation");
            if (talkingAnimation) {
                talkingAnimation.classList.add('active');
            }
        }

        function hideTalkingAnimation() {
            const talkingAnimation = document.getElementById("talking-animation");
            if (talkingAnimation) {
                talkingAnimation.classList.remove('active');
            }
        }

        // Voice Talk Functions
        const voiceTalkBtn = document.getElementById('voice-talk-btn');
        const micIcon = voiceTalkBtn.querySelector('i');
        const voiceModeOverlay = document.getElementById('voice-mode-overlay');
        const mainContentElement = document.querySelector('.main'); // Renamed to avoid conflict with local variable
        const micControlBtn = document.getElementById('mic-control-btn');
        const closeVoiceModeBtn = document.getElementById('close-voice-mode-btn');
        const voiceStatusTextOverlay = voiceModeOverlay.querySelector('.status-text');
        const screenShareBtn = document.getElementById('screen-share-btn'); // New screen share button

        function initializeSpeechRecognition() {
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false; // Only listen for a single utterance
                recognition.interimResults = false; // Only return final results
                recognition.lang = 'en-US'; // Set language

                recognition.onstart = () => {
                    isListening = true;
                    micControlBtn.classList.add('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone-alt'; // Listening icon
                    voiceStatusTextOverlay.textContent = 'Listening...';
                    console.log('Speech recognition started.');
                    stopSpeaking(); // Stop AI speech if user starts talking
                    startVoiceVisualizer(false); // Start visualizer for user input
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('text-input').value = transcript;
                    console.log('Speech recognized:', transcript);
                    // Automatically submit the form after speech is recognized
                    document.getElementById('multi-action-form').dispatchEvent(new Event('submit', { cancelable: true }));
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon on error
                    isListening = false;
                    stopVoiceVisualizer(); // Stop visualizer on error
                    let errorMessage = 'Speech error. Tap mic to retry.';
                    if (event.error === 'not-allowed') {
                        errorMessage = 'Microphone permission denied. Please allow access.';
                        addMessage("Microphone access denied. Please enable microphone permissions for this site in your browser settings to use voice features.", 'bot', null, new Date());
                    } else if (event.error === 'no-speech') {
                        errorMessage = 'No speech detected. Please try again.';
                    } else if (event.error === 'audio-capture') {
                        errorMessage = 'Microphone not found or busy. Check connections.';
                    } else if (event.error === 'network') {
                        errorMessage = 'Network error during speech recognition.';
                    }
                    voiceStatusTextOverlay.textContent = errorMessage;
                    // Do NOT automatically restart here, let user tap again
                };

                recognition.onend = () => {
                    console.log('Speech recognition ended.');
                    isListening = false;
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                    stopVoiceVisualizer(); // Stop visualizer when listening ends
                    if (isVoiceTalkActive && !isSpeaking) {
                        voiceStatusTextOverlay.textContent = 'Standard voice'; // Reset status text
                        // Only restart listening if AI is not speaking and voice mode is still active
                        // This will be handled by finalizeStreamingBotMessage or micControlBtn click
                    } else if (!isVoiceTalkActive) {
                        voiceStatusTextOverlay.textContent = 'Standard voice';
                    }
                };
            } else {
                voiceTalkBtn.disabled = true;
                voiceTalkBtn.title = "Voice talk not supported in your browser.";
                console.warn("Web Speech API not supported in this browser.");
                // Provide user feedback directly in chat if it's the first time they try
                addMessage("Your browser does not support Web Speech Recognition. Please use a compatible browser like Chrome or Edge.", 'bot', null, new Date());
            }
        }

        function startListening() {
            if (recognition && isVoiceTalkActive && !isListening && !isSpeaking) { // Ensure not speaking
                try {
                    recognition.start();
                } catch (e) {
                    console.warn("Recognition already started or other error:", e);
                    if (e.message.includes('already started')) {
                        // Ignore if already started, but log for debugging
                    } else if (e.message.includes('permission denied')) {
                        voiceStatusTextOverlay.textContent = 'Microphone permission denied. Please allow access.';
                        addMessage("Microphone access denied. Please enable microphone permissions for this site in your browser settings to use voice features.", 'bot', null, new Date());
                    } else {
                        voiceStatusTextOverlay.textContent = 'Error starting mic. Tap to retry.';
                        addMessage("An error occurred trying to start the microphone: " + e.message, 'bot', null, new Date());
                    }
                }
            } else if (!recognition) {
                voiceStatusTextOverlay.textContent = 'Speech API not available.';
                addMessage("Web Speech API is not available in your browser.", 'bot', null, new Date());
            }
        }

        function stopListening() {
            if (recognition && isListening) {
                recognition.stop();
            }
        }

        // Function to set the AI's voice
        function setAIVoice() {
            const voices = synth.getVoices();
            // Try to find a specific voice, e.g., a female voice, or one with a clear, standard accent.
            // You might need to inspect `voices` array in your browser's console to find suitable names.
            // Common names: 'Google US English', 'Microsoft Zira - English (United States)', 'Samantha' (iOS)
            selectedVoice = voices.find(voice => voice.name.includes('Google US English') && voice.lang === 'en-US' && voice.gender === 'female') ||
                            voices.find(voice => voice.name.includes('Zira') && voice.lang === 'en-US') ||
                            voices.find(voice => voice.lang === 'en-US' && voice.name.includes('Female')) ||
                            voices.find(voice => voice.lang === 'en-US') ||
                            voices[0]; // Fallback to the first available voice

            if (selectedVoice) {
                console.log("AI Voice selected:", selectedVoice.name, selectedVoice.lang);
            } else {
                console.warn("Could not find a specific AI voice, using default.");
            }
        }

        function speakText(text) {
            if (!isVoiceTalkActive || !synth || !selectedVoice) {
                console.warn("Speech synthesis not active, synth not available, or no voice selected. Cannot speak.");
                return;
            }

            speechQueue.push(text); // Add text to the queue
            processSpeechQueue(); // Start/continue processing the queue
        }

        function processSpeechQueue() {
            if (isProcessingSpeechQueue || speechQueue.length === 0) {
                return; // Already processing or nothing to speak
            }

            isProcessingSpeechQueue = true;
            stopListening(); // Stop listening while AI is speaking

            const textToSpeak = speechQueue.shift(); // Get the next text from the queue
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = 'en-US';
            utterance.pitch = 1.0; // Default pitch (0.1 to 2.0)
            utterance.rate = 1.0; // Default rate (0.1 to 10.0)
            utterance.voice = selectedVoice; // Apply the selected voice

            utterance.onstart = () => {
                isSpeaking = true;
                micControlBtn.classList.add('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-volume-up'; // Speaking icon
                voiceStatusTextOverlay.textContent = 'Speaking...';
                console.log('Speech synthesis started.');
                startVoiceVisualizer(true); // Start visualizer for AI speech (full screen overlay)
                showTalkingAnimation(); // Show subtle animation at bottom
            };

            utterance.onend = () => {
                console.log('Speech synthesis ended.');
                isSpeaking = false;
                stopVoiceVisualizer(); // Stop visualizer
                hideTalkingAnimation(); // Hide subtle animation
                isProcessingSpeechQueue = false; // Mark as done with current utterance

                if (speechQueue.length > 0) {
                    processSpeechQueue(); // Process next in queue
                } else {
                    // Only reset controls and restart listening if the entire queue is empty
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                    if (isVoiceTalkActive) {
                        voiceStatusTextOverlay.textContent = 'Standard voice'; // Reset status text
                        startListening(); // Restart listening after AI finishes speaking
                    }
                }
            };

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                isSpeaking = false;
                stopVoiceVisualizer(); // Stop visualizer
                hideTalkingAnimation(); // Hide subtle animation
                isProcessingSpeechQueue = false; // Mark as done with current utterance

                // Clear the rest of the queue on error to prevent cascading issues
                speechQueue = []; 

                micControlBtn.classList.remove('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon on error
                if (isVoiceTalkActive) {
                    voiceStatusTextOverlay.textContent = 'Speech error. Tap mic to retry.'; // More informative error
                    startListening(); // Try to restart listening
                }
            };

            synth.speak(utterance);
        }

        function stopSpeaking() {
            if (isSpeaking || isProcessingSpeechQueue) {
                synth.cancel(); // Stops current utterance
                speechQueue = []; // Clear any pending utterances
                isSpeaking = false;
                isProcessingSpeechQueue = false;
                micControlBtn.classList.remove('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                stopVoiceVisualizer(); // Stop any ongoing visualizer
                hideTalkingAnimation(); // Ensure subtle animation is hidden
            }
        }

        // Web Audio API Visualizer Logic
        async function initializeVoiceVisualizer() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.warn("getUserMedia not supported in this browser.");
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Fast Fourier Transform size
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

                canvas = document.getElementById('voice-circle-canvas');
                canvasCtx = canvas.getContext('2d');

                // Set canvas dimensions dynamically
                const setCanvasSize = () => {
                    const size = Math.min(window.innerWidth, window.innerHeight) * 0.5; // Max 50% of smaller dimension
                    canvas.width = size;
                    canvas.height = size;
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear after resize
                };
                setCanvasSize();
                window.addEventListener('resize', setCanvasSize);

                // Get microphone stream only once
                if (!microphoneStream) {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioContext.createMediaStreamSource(microphoneStream);
                    source.connect(analyser);
                    // analyser.connect(audioContext.destination); // Connect to speakers for monitoring, optional
                }
                
            } catch (err) {
                console.error("Error accessing microphone for visualizer:", err);
                // Disable voice features if mic access fails
                voiceTalkBtn.disabled = true;
                voiceTalkBtn.title = "Microphone access denied or not available.";
                micControlBtn.disabled = true;
                micControlBtn.title = "Microphone access denied or not available.";
                addMessage("Microphone access is required for voice visualization and input. Please enable it in your browser settings.", 'bot', null, new Date());
            }
        }

        function startVoiceVisualizer(isAIVoice = false) {
            if (!analyser || !canvasCtx) return;

            cancelAnimationFrame(animationFrameId); // Stop any existing animation
            
            const draw = () => {
                animationFrameId = requestAnimationFrame(draw);

                analyser.getByteFrequencyData(dataArray); // Get frequency data

                canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(centerX, centerY) * 0.7; // Max size

                // Calculate overall volume (amplitude)
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                let average = sum / bufferLength;
                let normalizedVolume = average / 128; // Normalize to 0-2 range (can exceed 1 for loud sounds)
                normalizedVolume = Math.min(2, Math.max(0, normalizedVolume)); // Clamp between 0 and 2

                const baseCircleRadius = Math.min(centerX, centerY) * 0.4;
                const maxCircleExpansion = Math.min(centerX, centerY) * 0.3; // Max expansion beyond base

                // Dynamic properties based on AI voice or user voice
                const mainColor = isAIVoice ? '106, 13, 173' : '16, 163, 127'; // Accent vs Primary
                const numRings = isAIVoice ? 7 : 5; // More rings for AI
                const baseLineWidth = isAIVoice ? 3 : 2; // Thicker lines for AI
                const maxLineWidthBoost = isAIVoice ? 7 : 5; // More boost for AI

                // Add a subtle rotation for AI voice
                if (isAIVoice) {
                    canvasCtx.save();
                    canvasCtx.translate(centerX, centerY);
                    canvasCtx.rotate(Date.now() * 0.001 % (2 * Math.PI)); // Faster continuous rotation for AI voice
                    canvasCtx.translate(-centerX, -centerY);
                }

                for (let i = 0; i < numRings; i++) {
                    const ringOffset = i * (maxCircleExpansion / numRings);
                    let currentRadius = baseCircleRadius + (normalizedVolume * maxCircleExpansion * 0.5) + ringOffset;
                    
                    // More dynamic animation for AI voice
                    const animationFactor = isAIVoice ? Math.sin(Date.now() * 0.008 + i * 0.7) * 0.07 : Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
                    currentRadius *= (1 + animationFactor);

                    const opacity = 0.1 + (normalizedVolume * 0.4) * (1 - (i / numRings));
                    const lineWidth = baseLineWidth + (normalizedVolume * maxLineWidthBoost) * (1 - (i / numRings));

                    canvasCtx.beginPath();
                    canvasCtx.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = `rgba(${mainColor}, ${opacity})`;
                    canvasCtx.lineWidth = lineWidth;
                    canvasCtx.stroke();
                }

                // Draw a central solid circle that pulses more
                const centralRadius = baseCircleRadius * 0.8 + (normalizedVolume * baseCircleRadius * 0.2);
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, centralRadius, 0, 2 * Math.PI);
                canvasCtx.fillStyle = `rgba(${mainColor}, ${0.5 + normalizedVolume * 0.4})`; // More opaque for AI
                canvasCtx.fill();

                if (isAIVoice) {
                    canvasCtx.restore(); // Restore canvas state after rotation
                }
            };
            draw();
        }

        function stopVoiceVisualizer() {
            cancelAnimationFrame(animationFrameId);
            if (canvasCtx) {
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            }
        }

        voiceTalkBtn.addEventListener('click', () => {
            isVoiceTalkActive = !isVoiceTalkActive;
            
            if (isVoiceTalkActive) {
                console.log("Voice Talk ON");
                voiceModeOverlay.classList.add('active'); // Show full-screen overlay
                mainContentElement.style.display = 'none'; // Hide main chat UI
                voiceStatusTextOverlay.textContent = 'Standard voice'; // Initial status for overlay
                startListening(); // Attempt to start listening
            } else {
                console.log("Voice Talk OFF");
                stopListening();
                stopSpeaking(); // Ensure all speech and visualizer are stopped
                stopVoiceVisualizer(); // Stop visualizer when exiting voice mode
                stopScreenShare(); // Stop screen share if active

                voiceModeOverlay.classList.remove('active'); // Hide full-screen overlay
                mainContentElement.style.display = 'flex'; // Show main chat UI

                micControlBtn.classList.remove('mic-active'); // Reset mic button on overlay
                micControlBtn.querySelector('i').className = 'fas fa-microphone';
            }
        });

        // Event listener for the mic button on the overlay
        micControlBtn.addEventListener('click', () => {
            if (isListening) {
                stopListening();
                voiceStatusTextOverlay.textContent = 'Tap mic to speak.'; // Prompt user to tap again
            } else {
                startListening();
            }
        });

        // Event listener for the close button on the overlay
        closeVoiceModeBtn.addEventListener('click', () => {
            isVoiceTalkActive = false; // Deactivate voice mode
            // Manually trigger the state change that voiceTalkBtn.click() would do
            stopListening();
            stopSpeaking();
            stopVoiceVisualizer();
            stopScreenShare(); // Stop screen share if active

            voiceModeOverlay.classList.remove('active');
            mainContentElement.style.display = 'flex';
            micControlBtn.classList.remove('mic-active');
            micControlBtn.querySelector('i').className = 'fas fa-microphone';
            showSendButton(); // Ensure send button is visible if not in voice mode
        });

        // NEW: Screen Share Functions
        screenShareBtn.addEventListener('click', () => {
            if (isScreenSharing) {
                stopScreenShare();
            } else {
                startScreenShare();
            }
        });

        async function startScreenShare() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                addMessage("Screen sharing not supported in your browser.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Screen sharing not supported in your browser.");
                console.warn("getDisplayMedia not supported.");
                return;
            }

            try {
                // Request screen share stream
                screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                screenShareVideoElement.srcObject = screenShareStream;
                screenSharePreviewContainer.style.display = 'flex'; // Show preview

                isScreenSharing = true;
                screenShareBtn.classList.add('screen-share-active');
                screenShareBtn.querySelector('i').className = 'fas fa-stop-circle'; // Stop icon

                // Listen for when the user stops sharing directly from the browser's UI
                screenShareStream.getVideoTracks()[0].onended = () => {
                    console.log("Screen share ended by user.");
                    stopScreenShare();
                };

                // Start capturing and sending frames
                screenShareInterval = setInterval(captureAndSendScreenFrame, 2000); // Send frame every 2 seconds
                addMessage("Screen sharing started. I will analyze your screen for issues.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Screen sharing started. I will analyze your screen for issues.");

            } catch (err) {
                console.error("Error starting screen share:", err);
                addMessage("Could not start screen sharing. Please ensure you grant permission.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Could not start screen sharing. Please ensure you grant permission.");
                isScreenSharing = false;
                screenShareBtn.classList.remove('screen-share-active');
                screenShareBtn.querySelector('i').className = 'fas fa-desktop';
                screenSharePreviewContainer.style.display = 'none';
            }
        }

        function stopScreenShare() {
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(track => track.stop());
                screenShareStream = null;
            }
            if (screenShareInterval) {
                clearInterval(screenShareInterval);
                screenShareInterval = null;
            }
            isScreenSharing = false;
            screenShareBtn.classList.remove('screen-share-active');
            screenShareBtn.querySelector('i').className = 'fas fa-desktop'; // Reset icon
            screenSharePreviewContainer.style.display = 'none'; // Hide preview
            addMessage("Screen sharing stopped.", 'bot', null, new Date());
            if (isVoiceTalkActive) speakText("Screen sharing stopped.");
        }

        async function captureAndSendScreenFrame() {
            if (!screenShareVideoElement || !isScreenSharing) return;

            // Set canvas dimensions to match video stream
            screenCaptureCanvas.width = screenShareVideoElement.videoWidth;
            screenCaptureCanvas.height = screenShareVideoElement.videoHeight;
            
            // Draw the current video frame onto the canvas
            screenCaptureCtx.drawImage(screenShareVideoElement, 0, 0, screenCaptureCanvas.width, screenCaptureCanvas.height);

            // Get base64 image data from the canvas
            const imageDataUrl = screenCaptureCanvas.toDataURL('image/jpeg', 0.7); // JPEG for compression, 70% quality
            const base64Image = imageDataUrl.split(',')[1]; // Remove "data:image/jpeg;base64," prefix

            try {
                const formData = new FormData();
                formData.append('image', base64Image);
                formData.append('chat_id', currentChatId);
                formData.append('instruction', 'Analyze this screenshot for any UI/code issues, errors, or areas for improvement. Suggest specific fixes or next steps, including code if applicable.');

                const response = await fetch(`${window.location.origin}/process_screen_frame`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data && data.response) {
                    addMessage(`**Screen Analysis:** ${data.response}`, 'bot', null, new Date());
                    if (isVoiceTalkActive) speakText(data.response);
                } else {
                    console.error("Screen analysis failed: No response from AI.");
                }
            } catch (error) {
                console.error("Error sending screen frame to AI:", error);
                // Optionally add a message to the chat about the error
            }
        }

        // NEW: Code Update Modal Functions
        const codeUpdateModal = document.getElementById('codeUpdateModal');
        const fileToUpdateSelect = document.getElementById('fileToUpdateSelect');
        const codeUpdateTextarea = document.getElementById('codeUpdateTextarea');
        const applyCodeUpdateBtn = document.getElementById('applyCodeUpdateBtn');

        window.openCodeUpdateModal = function(suggestedCode = '', fileType = 'html') {
            codeUpdateTextarea.value = suggestedCode;
            // Set the selected file type in the dropdown
            if (fileToUpdateSelect) {
                const options = Array.from(fileToUpdateSelect.options);
                const matchingOption = options.find(option => option.value.includes(fileType));
                if (matchingOption) {
                    fileToUpdateSelect.value = matchingOption.value;
                } else {
                    fileToUpdateSelect.value = 'index.html'; // Default
                }
            }
            codeUpdateModal.style.display = 'flex';
        };

        applyCodeUpdateBtn.addEventListener('click', async () => {
            const fileName = fileToUpdateSelect.value;
            const fileContent = codeUpdateTextarea.value;

            if (!fileName || !fileContent) {
                addMessage("Please select a file and provide content to update.", 'bot', null, new Date());
                return;
            }

            addMessage(`Attempting to update ${fileName}...`, 'user', null, new Date());
            codeUpdateModal.style.display = 'none'; // Hide modal immediately

            try {
                const formData = new FormData();
                formData.append('file_name', fileName);
                formData.append('file_content', fileContent);

                const response = await fetch(`${window.location.origin}/update_file`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.status === 'success') {
                    addMessage(`Successfully updated ${fileName}: ${data.message}`, 'bot', null, new Date());
                } else {
                    addMessage(`Failed to update ${fileName}: ${data.message}`, 'bot', null, new Date());
                }
            } catch (error) {
                console.error("Error applying code update:", error);
                addMessage(`Error communicating with server for file update: ${error.message}`, 'bot', null, new Date());
            }
        });


        async function updateChatHistory() {
            const chatHistoryList = document.getElementById('chat-history-list');
            chatHistoryList.innerHTML = ''; // Clear existing history
            try {
                const response = await fetch(`${window.location.origin}/get_chat_history_list`);
                const chatSummaries = await response.json(); 

                if (chatSummaries.length === 0) {
                    await startNewChat(true); // Start a new chat if no history
                } else {
                    chatSummaries.forEach(chatSummary => {
                        const chatLink = document.createElement('a');
                        chatLink.href = "#";
                        chatLink.className = `chat-link ${chatSummary.id === currentChatId ? 'active' : ''}`;
                        chatLink.setAttribute('data-chat-id', chatSummary.id); // Store chat ID
                        chatLink.setAttribute('data-chat-title', chatSummary.title); // Store chat title
                        chatLink.setAttribute('role', 'option');
                        chatLink.setAttribute('aria-selected', chatSummary.id === currentChatId ? 'true' : 'false');
                        chatLink.setAttribute('tabindex', '0'); // Make it focusable

                        const chatTitleSpan = document.createElement('span');
                        chatTitleSpan.textContent = chatSummary.title;
                        chatLink.appendChild(chatTitleSpan);

                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'chat-link-actions';

                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'rename-chat-btn';
                        renameBtn.innerHTML = '<i class="fas fa-edit" aria-hidden="true"></i>';
                        renameBtn.title = 'Rename Chat';
                        renameBtn.setAttribute('aria-label', `Rename chat ${chatSummary.title}`);
                        renameBtn.onclick = (e) => {
                            e.stopPropagation(); // Prevent loading chat when clicking rename
                            renameChat(chatSummary.id, chatSummary.title);
                        };
                        actionsDiv.appendChild(renameBtn);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-chat-btn';
                        deleteBtn.innerHTML = '<i class="fas fa-trash" aria-hidden="true"></i>';
                        deleteBtn.title = 'Delete Chat';
                        deleteBtn.setAttribute('aria-label', `Delete chat ${chatSummary.title}`);
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation(); // Prevent loading chat when clicking delete
                            deleteChat(chatSummary.id, chatSummary.title);
                        };
                        actionsDiv.appendChild(deleteBtn);

                        chatLink.appendChild(actionsDiv);

                        chatLink.onclick = (e) => {
                            e.preventDefault();
                            loadChat(chatSummary.id);
                        };
                        chatHistoryList.appendChild(chatLink);
                    });

                    // Load the most recent chat if no current chat is active
                    const isCurrentChatInList = chatSummaries.some(summary => summary.id === currentChatId);
                    if (!currentChatId || !isCurrentChatInList) {
                        currentChatId = chatSummaries[0].id; // Load the first chat by default
                        await loadChat(currentChatId);
                    } else {
                        await loadChat(currentChatId); // Reload current chat to update active state
                    }
                }
            } catch (error) {
                console.error("Error fetching chat history list:", error);
                addMessage("Failed to load chat history. Please try refreshing.", 'bot', null, new Date());
            }
        }

        async function loadChat(id) {
            const chatbox = document.getElementById('chatbox');
            const newChatPlaceholder = document.getElementById('new-chat-placeholder');
            currentChatId = id;
            chatbox.innerHTML = ''; // Clear chatbox before loading new chat

            try {
                const response = await fetch(`${window.location.origin}/get_chat_messages/${id}`);
                const chatData = await response.json(); 

                if (chatData.length === 0) {
                    // If loading an empty chat, show the placeholder
                    if (newChatPlaceholder) {
                        newChatPlaceholder.style.display = 'flex';
                    } else {
                        const placeholderDiv = document.createElement('div');
                        placeholderDiv.id = 'new-chat-placeholder';
                        placeholderDiv.className = 'new-chat-placeholder';
                        placeholderDiv.innerHTML = `
                            <i class="fas fa-robot logo-large" aria-hidden="true"></i>
                            <span class="title">What are you working on?</span>
                            <p>Welcome to Vexara! How can I assist you today?</p>
                        `;
                        chatbox.appendChild(placeholderDiv);
                    }
                } else {
                    // If there are messages, remove the placeholder if it exists
                    if (newChatPlaceholder) {
                        newChatPlaceholder.remove();
                    }
                    chatData.forEach(msg => {
                        const msgTimestamp = msg.timestamp ? new Date(msg.timestamp * 1000) : new Date();
                        if (msg.type === 'bot' && msg.image_urls && msg.image_urls.length > 0) {
                            addMessage(msg.text, msg.type, msg.image_urls, msgTimestamp);
                        } else if (msg.type === 'user' && msg.image_url) { 
                            const imgElement = document.createElement('img');
                            imgElement.src = msg.image_url;
                            imgElement.classList.add('uploaded-image-preview');
                            addMessage(msg.text, msg.type, imgElement, msgTimestamp);
                        } else {
                            addMessage(msg.text, msg.type, null, msgTimestamp);
                        }
                    });
                }
                

                // Update active state in chat history list
                document.querySelectorAll('.chat-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                const activeLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                if (activeLink) {
                    activeLink.classList.add('active');
                    activeLink.setAttribute('aria-selected', 'true');
                }

                scrollToBottom();
            } catch (error) {
                console.error(`Error loading chat data for ${id}:`, error);
                addMessage("Failed to load chat. It might have been deleted or corrupted.", 'bot', null, new Date());
            }
        }

        // NEW: Function to rename a chat
        async function renameChat(chatId, currentTitle) {
            const newTitle = prompt(`Rename chat "${currentTitle}":`, currentTitle);
            if (newTitle && newTitle.trim() !== currentTitle) {
                try {
                    const response = await fetch(`${window.location.origin}/rename_chat/${chatId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ new_title: newTitle.trim() }),
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        addMessage(`Chat "${currentTitle}" renamed to "${newTitle}".`, 'bot', null, new Date());
                        await updateChatHistory(); // Refresh the sidebar
                    } else {
                        addMessage(`Failed to rename chat: ${result.error}`, 'bot', null, new Date());
                    }
                } catch (error) {
                    console.error("Error renaming chat:", error);
                    const userErrorMessage = error.message.includes('Failed to fetch') ? 
                                               'Could not connect to the server. Please check your network connection and ensure the server is running.' : 
                                               `An unexpected network error occurred: ${error.message}.`;
                    addMessage(`Network error while renaming chat: ${userErrorMessage} Please try again.`, 'bot', null, new Date());
                }
            } else if (newTitle !== null && newTitle.trim() === '') {
                addMessage("Chat title cannot be empty.", 'bot', null, new Date());
            }
        }

        // NEW: Function to delete a chat
        async function deleteChat(chatId, chatTitle) {
            // Use the existing confirm modal for deletion
            const confirmModal = document.getElementById('confirmModal');
            const modalTitle = confirmModal.querySelector('h3');
            const modalParagraph = confirmModal.querySelector('p');
            const confirmBtn = document.getElementById('confirmClearBtn');
            const cancelBtn = confirmModal.querySelector('.modal-btn.cancel');

            modalTitle.textContent = `Delete Chat "${chatTitle}"?`;
            modalParagraph.textContent = `Are you sure you want to delete "${chatTitle}"? This action cannot be undone.`;
            confirmBtn.textContent = 'Delete';
            confirmBtn.classList.remove('confirm'); // Remove 'confirm' class for general clear all
            confirmBtn.classList.add('modal-btn', 'confirm'); // Re-add for delete specific styling

            // Temporarily remove previous listener and add new one for this specific action
            const oldConfirmListener = confirmBtn.onclick;
            confirmBtn.onclick = null; // Clear existing listener
            confirmBtn.addEventListener('click', async function handler() {
                try {
                    const response = await fetch(`${window.location.origin}/delete_chat/${chatId}`, {
                        method: 'POST',
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        addMessage(`Chat "${chatTitle}" deleted.`, 'bot', null, new Date());
                        if (chatId === currentChatId) {
                            // If the current chat was deleted, start a new one
                            await startNewChat();
                        } else {
                            await updateChatHistory(); // Refresh the sidebar
                        }
                    } else {
                        addMessage(`Failed to delete chat: ${result.error}`, 'bot', null, new Date());
                    }
                } catch (error) {
                    console.error("Error deleting chat:", error);
                    const userErrorMessage = error.message.includes('Failed to fetch') ? 
                                               'Could not connect to the server. Please check your network connection and ensure the server is running.' : 
                                               `An unexpected network error occurred: ${error.message}.`;
                    addMessage(`Network error while deleting chat: ${userErrorMessage} Please try again.`, 'bot', null, new Date());
                } finally {
                    hideModal();
                    // Restore original confirm button listener if needed, or just keep it null for next use
                    confirmBtn.onclick = oldConfirmListener; 
                    confirmBtn.removeEventListener('click', handler); // Remove this specific handler
                    // Reset modal text to default for clear all chats
                    modalTitle.textContent = `Clear All Chats?`;
                    modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
                    confirmBtn.textContent = 'Clear All';
                    confirmBtn.classList.remove('confirm');
                    confirmBtn.classList.add('modal-btn', 'confirm');
                }
            }, { once: true }); // Use { once: true } to automatically remove listener after first execution

            if (confirmModal) confirmModal.style.display = 'flex';
        }


        // Initialize the app on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async function () {
            // Apply dark mode if previously enabled
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
            }

            // Highlight all existing code blocks on load
            hljs.highlightAll();

            // Initialize Speech Recognition and Visualizer
            initializeSpeechRecognition();
            initializeVoiceVisualizer();

            // Initialize Speech Synthesis Voices
            if ('SpeechSynthesisUtterance' in window && 'speechSynthesis' in window) {
                synth = window.speechSynthesis;
                synth.onvoiceschanged = setAIVoice; // Listen for voices to be loaded
                setAIVoice(); // Call immediately in case voices are already loaded
            } else {
                console.warn("Web Speech Synthesis API not supported.");
                addMessage("Your browser does not support Web Speech Synthesis (AI voice output). Please use a compatible browser like Chrome or Edge.", 'bot', null, new Date());
            }

            // Element References (re-get if needed due to new elements)
            const sidebar = document.getElementById('sidebar');
            const showSidebarBtn = document.getElementById('showSidebarBtn');
            const sidebarToggleButton = document.getElementById('sidebarToggleButton'); // Changed from hideSidebarBtn
            const textInput = document.getElementById('text-input');
            const multiActionForm = document.getElementById('multi-action-form');
            const cameraOptions = document.querySelector('.camera-options');
            const takePhotoInput = document.getElementById('take-photo-input'); // NEW: Get the actual input
            const uploadPhotoInput = document.getElementById('upload-photo-input'); // NEW: Get the actual input
            const desktopFileInput = document.getElementById('desktop-file-input'); // NEW: Get the desktop file input
            const cancelCameraBtn = document.getElementById('cancel-camera');
            const clearImageBtn = document.getElementById('clear-image-btn'); // Get clear image button
            const clearAllChatsBtn = document.getElementById('clearAllChatsBtn');
            const confirmClearBtn = document.getElementById('confirmClearBtn');
            const modal = document.getElementById('confirmModal');
            const webSearchBtn = document.getElementById('web-search-btn'); // Get the new web search button
            const sendBtn = document.getElementById('send-btn'); // Reference to the send button
            const stopBtn = document.getElementById('stop-btn'); // Reference to the stop button
            const attachFileBtn = document.getElementById('attach-file-btn'); // NEW: Get the attach file button

            // New: Get radio buttons for model selection
            const modelGeneralRadio = document.getElementById('modelGeneral');
            const modelDeepThinkRadio = document.getElementById('modelDeepThink');
            // Removed fileInputLabel as it's now attachFileBtn

            // Event Listeners for UI interaction
            // Use sidebarToggleButton for collapsing/expanding the sidebar from inside
            if (sidebarToggleButton) sidebarToggleButton.addEventListener('click', toggleSidebar);
            // Use showSidebarBtn for showing the sidebar when it's fully hidden (mobile or desktop full screen)
            if (showSidebarBtn) showSidebarBtn.addEventListener('click', toggleSidebar);

            if (clearImageBtn) clearImageBtn.addEventListener('click', clearImagePreview); // Event listener for clear image button
            if (stopBtn) { // NEW: Add event listener for the stop button
                stopBtn.addEventListener('click', function() {
                    if (abortController) {
                        abortController.abort(); // Abort the ongoing fetch request
                    }
                    showSendButton(); // Immediately show send button
                    document.getElementById('loader').style.display = 'none'; // Hide loader
                    stopSpeaking(); // Stop any ongoing speech
                });
            }

            // Responsive window resize handling
            window.addEventListener('resize', () => {
                // Adjust sidebar and main content behavior on resize
                const mainContent = document.querySelector('.main');
                if (window.innerWidth <= 768) {
                    // On mobile, ensure sidebar is not 'collapsed' but rather 'visible' for slide-out
                    if (sidebar.classList.contains('collapsed')) {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('full-width');
                    }
                } else {
                    // On desktop, hide floating button if sidebar is open
                    // Restore sidebar visibility based on previous state if on desktop
                    if (!sidebarHidden) { // Only if not manually hidden
                         sidebar.classList.remove('collapsed');
                         mainContent.classList.remove('full-width');
                    }
                }
                updateSidebarToggleButtonVisibility(); // Always call this on resize to ensure correct button state
            });

            // Auto-resize textarea based on content
            if (textInput) {
                textInput.addEventListener('input', () => {
                    textInput.style.height = 'auto'; // Reset height
                    textInput.style.height = (textInput.scrollHeight) + 'px'; // Set to scroll height
                    // Toggle active class for send button based on text input
                    if (textInput.value.trim().length > 0) {
                        sendBtn.classList.add('active');
                    } else {
                        sendBtn.classList.remove('active');
                    }
                });

                // NEW: Handle Enter key to send message
                textInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent new line
                        multiActionForm.dispatchEvent(new Event('submit', { cancelable: true })); // Trigger form submission
                    }
                });
            }

            // Handle web search button click
            if (webSearchBtn) {
                webSearchBtn.addEventListener('click', async function() {
                    const userText = textInput.value.trim();
                    if (!userText) {
                        console.error("Please enter a search query.");
                        addMessage("Please enter a search query.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Please enter a search query.");
                        return;
                    }
                    // Add user message immediately
                    addMessage(`Searching the web for: "${userText}"`, 'user', null, new Date());
                    
                    const loaderElement = document.getElementById('loader');
                    loaderElement.style.display = 'block'; // Show loader
                    showStopButton(); // Show stop button
                    stopSpeaking(); // Stop AI speech if any

                    try {
                        // Call askAI with the web_search flag set to true
                        const modelChoice = document.querySelector('input[name="modelChoice"]:checked').value;
                        await askAI(userText, modelChoice, true); // Pass true for performSearch
                    } catch (error) {
                        console.error("Web search button error:", error);
                        addMessage("Sorry, an unexpected error occurred during web search. Please try again.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Sorry, an unexpected error occurred during web search. Please try again.");
                    } finally {
                        loaderElement.style.display = 'none'; // Hide loader
                        textInput.value = '';
                        textInput.style.height = 'auto';
                        textInput.focus();
                        sendBtn.classList.remove('active'); // Remove active class after sending
                        showSendButton(); // Show send button
                    }
                });
            }

            // Camera options for mobile (take photo/upload from gallery)
            // Show camera options when the attach file button is clicked on mobile
            if (attachFileBtn) { // NEW: Use attachFileBtn
                attachFileBtn.addEventListener('click', function(event) {
                    if (window.innerWidth <= 768) {
                        event.preventDefault(); // Prevent default button behavior on mobile if we're showing a modal first
                        cameraOptions.style.display = 'block';
                    } else {
                        // On desktop, directly trigger the hidden file input
                        desktopFileInput.click();
                    }
                });
            }

            // NEW: Event listeners for the actual hidden file inputs (mobile)
            if (takePhotoInput) {
                takePhotoInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        showImagePreview(this.files[0]);
                    }
                    cameraOptions.style.display = 'none'; // Always hide options once file selection attempt is done
                });
            }

            if (uploadPhotoInput) {
                uploadPhotoInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        showImagePreview(this.files[0]);
                    }
                    cameraOptions.style.display = 'none'; // Always hide options once file selection attempt is done
                });
            }

            // NEW: Event listener for the desktop file input
            // This listener is still needed even if the input is clicked programmatically
            if (desktopFileInput) {
                desktopFileInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        showImagePreview(this.files[0]);
                    } else {
                        clearImagePreview(); // Clear preview if user cancels desktop file picker
                    }
                });
            }

            if (cancelCameraBtn) {
                cancelCameraBtn.addEventListener('click', function() {
                    if (cameraOptions) cameraOptions.style.display = 'none';
                    clearImagePreview(); // Clear preview on cancel
                });
            }

            // Handle form submission based on input content and attached files
            if (multiActionForm) {
                multiActionForm.addEventListener('submit', async function (e) {
                    e.preventDefault(); // Prevent default form submission
                    const loaderElement = document.getElementById('loader');
                    loaderElement.style.display = 'block'; // Show loader for all submission types
                    showStopButton(); // Show stop button on submit
                    stopSpeaking(); // Stop AI speech if any

                    const userText = textInput.value.trim();
                    const modelChoice = document.querySelector('input[name="modelChoice"]:checked').value; // Get selected model
                    
                    // Determine which file input (if any) has a file
                    let selectedFile = null;
                    if (takePhotoInput && takePhotoInput.files.length > 0) {
                        selectedFile = takePhotoInput.files[0];
                    } else if (uploadPhotoInput && uploadPhotoInput.files.length > 0) {
                        selectedFile = uploadPhotoInput.files[0];
                    } else if (desktopFileInput && desktopFileInput.files.length > 0) { // NEW: Check desktop input
                        selectedFile = desktopFileInput.files[0];
                    }
                    const hasFile = selectedFile !== null;

                    try {
                        if (hasFile) {
                            // Assume image upload if a file is present
                            // Add user message with image preview immediately (optimistic update)
                            const imgElementForChat = document.createElement('img');
                            imgElementForChat.src = document.getElementById('image-preview').src; 
                            imgElementForChat.classList.add('uploaded-image-preview');
                            const caption = userText ? `Image with caption: "${userText}"` : 'Uploaded image';
                            addMessage(caption, 'user', imgElementForChat, new Date());
                            
                            // Now call the function that handles backend interaction
                            await uploadImage(selectedFile, userText); 
                        } else {
                            // Check for special commands
                            const lowerCaseText = userText.toLowerCase();

                            if (lowerCaseText.startsWith('generate image of') || 
                                lowerCaseText.startsWith('create an image of') ||
                                lowerCaseText.startsWith('picture of') ||
                                lowerCaseText.startsWith('draw a') ||
                                lowerCaseText.startsWith('make an image of')) {
                                addMessage(userText, 'user', null, new Date()); // Add user text message immediately
                                await generateImage(userText);
                            } else if (lowerCaseText.startsWith('explain code')) {
                                addMessage(userText, 'user', null, new Date());
                                await explainCode(userText.replace('explain code', '').trim());
                            } else if (lowerCaseText.startsWith('grammar check')) {
                                addMessage(userText, 'user', null, new Date());
                                await checkGrammarAndStyle(userText.replace('grammar check', '').trim());
                            } else if (lowerCaseText.startsWith('show html code') || lowerCaseText.startsWith('show app html')) {
                                addMessage("Requesting application HTML code...", 'user', null, new Date());
                                const response = await fetch(`${window.location.origin}/get_app_html`);
                                const htmlCode = await response.text(); 
                                
                                loaderElement.style.display = 'none';
                                showSendButton(); 

                                addMessage("Here is the current HTML code for the AI Assistant app:", 'bot', null, new Date());
                                const codeMessage = document.createElement('div');
                                codeMessage.className = `chat-message bot-message pulse`;
                                const codeContentDiv = document.createElement('div');
                                codeContentDiv.className = 'message-content';
                                codeContentDiv.innerHTML = marked.parse(`\`\`\`html\n${htmlCode}\n\`\`\``); 
                                codeMessage.appendChild(codeContentDiv);
                                document.getElementById('chatbox').appendChild(codeMessage);
                                scrollToBottom();
                                hljs.highlightAll(); 

                                if (isVoiceTalkActive) speakText("Here is the current HTML code for the AI Assistant app.");

                            }
                            else if (!userText) {
                                console.error("Please enter your input.");
                                addMessage("Please enter your input.", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("Please enter your input.");
                                return;
                            }
                            else {
                                // Default to Ask AI
                                addMessage(userText, 'user', null, new Date()); // Add user text message immediately
                                await askAI(userText, modelChoice); // Pass modelChoice
                            }
                        }
                    } catch (error) {
                        console.error("Submission error:", error);
                        addMessage("Sorry, an unexpected error occurred. Please try again.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Sorry, an unexpected error occurred. Please try again.");
                    } finally {
                        loaderElement.style.display = 'none';
                        textInput.value = '';
                        textInput.style.height = 'auto';
                        textInput.focus();
                        clearImagePreview();
                        sendBtn.classList.remove('active'); // Remove active class after sending
                        showSendButton(); // Ensure send button is shown after any submission type
                    }
                });
            }

            // Clear all chats confirmation and action
            if (clearAllChatsBtn) {
                clearAllChatsBtn.addEventListener('click', function() {
                    // Reset modal to "Clear All Chats" default before showing
                    const modalTitle = modal.querySelector('h3');
                    const modalParagraph = modal.querySelector('p');
                    const confirmBtn = document.getElementById('confirmClearBtn');

                    modalTitle.textContent = `Clear All Chats?`;
                    modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
                    confirmBtn.textContent = 'Clear All';
                    confirmBtn.classList.remove('confirm'); // Ensure it has default confirm styling
                    confirmBtn.classList.add('modal-btn', 'confirm');

                    // Remove any previous specific delete handler and add the general clear all handler
                    confirmBtn.onclick = null; // Clear previous listeners
                    confirmBtn.addEventListener('click', async function handler() {
                        try {
                            const response = await fetch(`/clear_all_chats`, { method: 'POST' });
                            const result = await response.json();

                            if (result.status === 'success') {
                                currentChatId = null; // Reset current chat ID
                                document.getElementById('chatbox').innerHTML = ''; // Clear chat messages
                                // Add the new chat placeholder back
                                const chatbox = document.getElementById('chatbox');
                                const placeholderDiv = document.createElement('div');
                                placeholderDiv.id = 'new-chat-placeholder';
                                placeholderDiv.className = 'new-chat-placeholder';
                                placeholderDiv.innerHTML = `
                                    <i class="fas fa-robot logo-large" aria-hidden="true"></i>
                                    <span class="title">What are you working on?</span>
                                    <p>Welcome to Vexara! How can I assist you today?</p>
                                `;
                                chatbox.appendChild(placeholderDiv);

                                addMessage("All chat history cleared. How can I help you?", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("All chat history cleared. How can I help you.");
                                await updateChatHistory(); // Refresh sidebar history
                                if (modal) modal.style.display = 'none';
                            } else {
                                console.error("Failed to clear chats:", result.error || "Unknown error.");
                                addMessage("Failed to clear chats. Please try again.", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("Failed to clear chats. Please try again.");
                            }
                        } catch (error) {
                            console.error("Network error while clearing chats:", error);
                            addMessage("Network error while clearing chats. Please try again.", 'bot', null, new Date());
                            if (isVoiceTalkActive) speakText("Network error while clearing chats. Please try again.");
                        } finally {
                            if (modal) modal.style.display = 'none';
                            confirmBtn.removeEventListener('click', handler); // Remove this specific handler
                        }
                    }, { once: true }); // Use { once: true } to automatically remove listener after first execution

                    if (modal) modal.style.display = 'flex';
                });
            }

            // Initial setup on page load
            await updateChatHistory(); // Load existing chat history or start new chat
            
            // Fetch user info (assuming a /user_info endpoint)
            fetch('/user_info')
                .then(response => response.json())
                .then(data => {
                    const userInfoDiv = document.getElementById('user-info');
                    const userEmailSpan = document.getElementById('user-email');
                    if (data.user_email) {
                        userEmailSpan.textContent = data.user_email;
                        userInfoDiv.style.display = 'flex'; // Show user info if email exists
                    } else {
                        userInfoDiv.style.display = 'none';
                    }
                })
                .catch(error => console.error('Error fetching user info:', error));
            
            // Initial desktop sidebar state
            if (window.innerWidth > 768) {
                sidebar.classList.remove('collapsed');
                mainContentElement.classList.remove('full-width');
                sidebarHidden = false; // Sidebar starts open
            }
            updateSidebarToggleButtonVisibility(); // Set initial button visibility correctly
        });

        // Demo: Show animation during speech synthesis
        // This function is for demonstration purposes and uses the new show/hide functions.
        function speakWithAnimation(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.onstart = () => {
                showTalkingAnimation();
                // If you also want the full canvas visualizer for this demo:
                // startVoiceVisualizer(true); 
            };
            utterance.onend = () => {
                hideTalkingAnimation();
                // If you were using the full canvas visualizer for this demo:
                // stopVoiceVisualizer();
            };
            utterance.onerror = () => {
                hideTalkingAnimation();
                // If you were using the full canvas visualizer for this demo:
                // stopVoiceVisualizer();
            };
            speechSynthesis.speak(utterance);
        }
    </script>

</body>
</html>
